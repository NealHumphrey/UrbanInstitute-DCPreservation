<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Azavea.Open.DAO</name>
    </assembly>
    <members>
        <member name="T:Azavea.Open.DAO.ClassMapping">
            <summary>
            Represents a mapping of a class onto a database table.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.TypeName">
            <summary>
            The class name that is being mapped.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.ClassType">
            <summary>
            The class that is being mapped.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.Constructor">
            <summary>
            The constructor that takes no parameters.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.Table">
            <summary>
            The table it is being mapped to.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.IdDataColsByObjAttrs">
            <summary>
            The columns that comprise the ID.
            Key:   Class Property/Attribute
            Value: DB Column
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.NonIdDataColsByObjAttrs">
            <summary>
            All the columns that aren't part of the ID.
            Key:   Class Property/Attribute
            Value: DB Column name
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.AllDataColsByObjAttrs">
            <summary>
            IDCols + PropertyCols together.
            Key:   Class Property/Attribute Name
            Value: DB Column name
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.IdDataColsByObjMemberInfo">
            <summary>
            The columns that comprise the ID.
            Key:   Class Property/Attribute MemberInfo
            Value: DB Column name
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.NonIdDataColsByObjMemberInfo">
            <summary>
            All the columns that aren't part of the ID.
            Key:   Class Property/Attribute MemberInfo
            Value: DB Column name
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.AllDataColsByObjMemberInfo">
            <summary>
            IDCols + PropertyCols together.
            Key:   Class Property/Attribute MemberInfo
            Value: DB Column name
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.AllDataColsInOrder">
            <summary>
            The DB column names in the order they appeared in the mapping file.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.AllObjMemberInfosByDataCol">
            <summary>
            The MemberInfos keyed by the column name (case insensitive since column names
            read from the data source may or may not be in the expected case).
            Key:   DB Column name
            Value: Class Property/Attribute MemberInfo
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.AllObjMemberInfosByObjAttr">
            <summary>
            The MemberInfos keyed by the column name.
            Key:   Class Property/Attribute Name
            Value: Class Property/Attribute MemberInfo
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.AllObjAttrsByDataCol">
            <summary>
            The class attribute names keyed by the column name (case insensitive since column names
            read from the data source may or may not be in the expected case).
            Key:   DB Column name
            Value: Class Property/Attribute Name
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.IdGeneratorsByDataCol">
            <summary>
            For each ID column, what type of generator do we use (case insensitive since column names
            read from the data source may or may not be in the expected case).
            Key:   Column name
            Value: Generator type.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.IdSequencesByDataCol">
            <summary>
            For each ID column, what sequence (if any) do we use.  Only populated for IDs
            with GeneratorType SEQUENCE.
            Key:   Column name (case insensitive since column names
                   read from the data source may or may not be in the expected case)
            Value: Sequence name.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.DataColTypesByObjAttr">
            <summary>
            Column types, if specified in the mapping file.
            Key:   Class Property/Attribute Name
            Value: Type string from the mapping file, or null if none was specified.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapping.DataColTypesByDataCol">
            <summary>
            Column types, if specified in the mapping file.
            Key:   Column name (case insensitive since column names
                   read from the data source may or may not be in the expected case)
            Value: Type string from the mapping file, or null if none was specified.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.ClassMapping.#ctor(System.Xml.XmlNode)">
            <summary>
            Construct it from an NHibernate config's "class" node.  Will not include
            foreign keys by default.
            </summary>
            <param name="hibConfNode">The XML configuration.</param>
        </member>
        <member name="M:Azavea.Open.DAO.ClassMapping.#ctor(System.Xml.XmlNode,System.Boolean)">
            <summary>
            Construct it from an NHibernate config's "class" node.
            This allows you to skip using reflection to populate the class info,
            if for example your Dao doesn't use it for some reason.
            Will not include foreign keys by default.
            </summary>
            <param name="hibConfNode">The XML configuration.</param>
            <param name="reflect">Whether or not to use reflection to populate all the class info.</param>
        </member>
        <member name="M:Azavea.Open.DAO.ClassMapping.#ctor(System.Xml.XmlNode,System.Boolean,System.Boolean)">
            <summary>
            Construct it from an NHibernate config's "class" node.
            This allows you to skip using reflection to populate the class info,
            if for example your Dao doesn't use it for some reason.
            This also allows you to specify whether to include many-to-one and one-to-one
            links as properties (may break FastDAO since the type of the attribute on the object
            will need to be the foreign key type (I.E. int) rather than the real object type of
            the relationship, which is what NHibernate expects).
            </summary>
            <param name="hibConfNode">The XML configuration.</param>
            <param name="reflect">Whether or not to use reflection to populate all the class info.</param>
            <param name="includeForeignKeys">If true, many-to-one and one-to-one
                                             links will be included as properties.</param>
        </member>
        <member name="M:Azavea.Open.DAO.ClassMapping.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{Azavea.Open.DAO.ClassMapColDefinition})">
            <summary>
            A constructor that allows you to explicitly declare the type, table name, and column mappings, 
            without using an XML mapping string.  (e.g. if you want to store mapping info in a database)
            </summary>
            <param name="typeName">The fully-qualified Class,Assembly type name for the object.</param>
            <param name="tableName">The data source table name.</param>
            <param name="colDefinitions">List of column mappings.</param>
        </member>
        <member name="M:Azavea.Open.DAO.ClassMapping.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{Azavea.Open.DAO.ClassMapColDefinition},System.Boolean)">
            <summary>
            A constructor that allows you to explicitly declare the type, table name, and column mappings, 
            without using an XML mapping string.  (e.g. if you want to store mapping info in a database)
            </summary>
            <param name="typeName">The fully-qualified Class,Assembly type name for the object.</param>
            <param name="tableName">The data source table name.</param>
            <param name="colDefinitions">List of column mappings.</param>
            <param name="reflect">Whether or not to use reflection to populate all the class info.</param>
        </member>
        <member name="M:Azavea.Open.DAO.ClassMapping.ToString">
            <summary>
            Returns the class mapping type name and table name.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.AsciiString">
            <summary>
            The purpose of this class is to represent in a mapping file that a .NET (unicode) string
            is being mapped to an ASCII varchar column.  Not marking the column as this
            type will still work, but may have performance implications because the DB will
            be casting the value at query execution time.
            This has been demonistrated on SQL Server 2005, and could not be reproduced
            on Oracle 10.2.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.ClassMapColDefinition">
            <summary>
            A class that encapsulates the properties need to define a column mapping in a ClassMapping object.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapColDefinition.Property">
            <summary>
            The name of the property on the data class type.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapColDefinition.Column">
            <summary>
            The name of the column in the data source.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapColDefinition.Type">
            <summary>
            The string name of the data type (not necessarily a .NET class name).  May be null if you
            don't want to exlicitly map the type.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.ClassMapColDefinition.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.ClassMapColDefinition.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructor to populate all the needed properties.
            </summary>
            <param name="name">The object property name.</param>
            <param name="column">The data source column name.</param>
            <param name="type">The data type (optional).</param>
        </member>
        <member name="T:Azavea.Open.DAO.ClassMapIDColDefinition">
            <summary>
            Extends ClassMapColDefinition, and adds properties needed to define an ID column.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapIDColDefinition.Generator">
            <summary>
            Whether or not the data source will use a generator to make Auto-IDs
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ClassMapIDColDefinition.Sequence">
            <summary>
            The sequence name, if one is used to generate the Auto-ID
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.ClassMapIDColDefinition.#ctor(System.String,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Constructor to populate all the needed properties.
            </summary>
            <param name="name">The object property name.</param>
            <param name="column">The data source column name.</param>
            <param name="type">The data type (optional).</param>
            <param name="generator">Whether or not the data source will use a generator to make Auto-IDs.</param>
            <param name="sequence">The sequence name, if one is used to generate the Auto-ID.</param>
        </member>
        <member name="T:Azavea.Open.DAO.ConnectionDescriptor">
            <summary>
            This class represents the information needed to establish a connection to a data source.
            This class is abstract, and may be extended to represent a connection to any .NET
            data provider (or anything else that makes sense).
            
            This class, and any that extend it, should be thread safe.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.IConnectionDescriptor">
            <summary>
            This interface represents the information needed to establish a connection to a data source.
            
            Any class that implements this interface should be thread safe.  If not, it should be well
            documented.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IConnectionDescriptor.ToCompleteString">
            <summary>
            Since we often need to represent database connection info as strings,
            child classes must implement ToCompleteString() such that this.Equals(that) and
            this.ToCompleteString().Equals(that.ToCompleteString()) will behave the same.
            </summary>
            <returns>A string representation of all of the connection info.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IConnectionDescriptor.ToCleanString">
            <summary>
            This method is similar to ToString, except it will not contain any
            "sensitive" information, I.E. passwords.
            
            This method is intended to be used for logging or error handling, where
            we do not want to display passwords to (potentially) just anyone, but
            we do want to indicate what DB connection we were using.
            </summary>
            <returns>A string representation of most of the connection info, except
                     passwords or similar items that shouldn't be shown.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IConnectionDescriptor.CreateDataAccessLayer">
            <summary>
            Returns the appropriate data access layer for this connection.  If this connection
            is capable of performing "DDL" operations (creating / deleting datastores, indexes, etc)
            this IDaLayer will also implement IDaDdlLayer.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.ConnectionDescriptor._log">
            <summary>
            The log4net logger which child classes may use to log any appropriate messages.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.ConnectionDescriptor.LoadFromConfig(Azavea.Open.Common.Config,System.String)">
            <summary>
            This is a factory method, that will load the appropriate type of connection
            descriptor using the given config.
            
            It first searches for config item(s) called "ConnectionConfigSection" and/or
            "ConnectionConfig".  (ConnectionConfig should be an "app name" for a config, not a file name).
            If present, it will use those to load from another section in this or another
            config file.  This allows more dynamic install-time configuration of DB connections.
            You may daisy-chain the configuration if you wish.
            
            Once in the connection configuration section, it will first search for the "DescriptorClass"
            config item, and use that class if specified.  If not, defaults to an OleDbDescriptor
            (which means it should be backwards compatible for all our existing config files).
            </summary>
            <param name="cfg">Config to load the descriptor info from.</param>
            <param name="section">What section of that config has the DB connection info in it.</param>
            <returns>A fully populated ConnectionDescriptor.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.ConnectionDescriptor.LoadFromConfig(Azavea.Open.Common.Config,System.String,Azavea.Open.DAO.ConnectionInfoDecryptionDelegate)">
            <summary>
            This is a factory method, that will load the appropriate type of connection
            descriptor using the given config.
            
            It first searches for config item(s) called "ConnectionConfigSection" and/or
            "ConnectionConfig".  (ConnectionConfig should be an "app name" for a config, not a file name).
            If present, it will use those to load from another section in this or another
            config file.  This allows more dynamic install-time configuration of DB connections.
            You may daisy-chain the configuration if you wish.
            
            Once in the connection configuration section, it will first search for the "DescriptorClass"
            config item, and use that class if specified.  If not, defaults to an OleDbDescriptor
            (which means it should be backwards compatible for all our existing config files).
            </summary>
            <param name="cfg">Config to load the descriptor info from.</param>
            <param name="section">What section of that config has the DB connection info in it.</param>
            <param name="decryptionDelegate">Method to call to decrypt information, if the actual
                                             connection descriptor type supports decryption.  May be null.</param>
            <returns>A fully populated ConnectionDescriptor.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.ConnectionDescriptor.ToString">
            <summary>
            For convenience, this returns ToCleanString().
            </summary>
            <returns>A string representation of this connection information.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.ConnectionDescriptor.ToCompleteString">
            <summary>
            Since we often need to represent database connection info as strings,
            child classes must implement ToCompleteString() such that this.Equals(that) and
            this.ToCompleteString().Equals(that.ToCompleteString()) will behave the same.
            </summary>
            <returns>A string representation of all of the connection info.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.ConnectionDescriptor.ToCleanString">
            <summary>
            This method is similar to ToString, except it will not contain any
            "sensitive" information, I.E. passwords.
            
            This method is intended to be used for logging or error handling, where
            we do not want to display passwords to (potentially) just anyone, but
            we do want to indicate what DB connection we were using.
            </summary>
            <returns>A string representation of most of the connection info, except
                     passwords or similar items that shouldn't be shown.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.ConnectionDescriptor.CreateDataAccessLayer">
            <summary>
            Returns the appropriate data access layer for this connection.  If this connection
            is capable of performing "DDL" operations (creating / deleting datastores, indexes, etc)
            this IDaLayer will also implement IDaDdlLayer.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.ConnectionDescriptor.Equals(System.Object)">
            <summary>
            The default implementation does a comparison based on ToCompleteString.  If this is
            inaccurate or inefficient for a given implementation, this method should be
            overridden.
            </summary>
            <param name="obj">Other descriptor to compare with.</param>
            <returns>True if the two descriptors describe identical connections to a database.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.ConnectionDescriptor.GetHashCode">
            <summary>
            The default implementation uses the hashcode of ToCompleteString.  If this is
            inaccurate or inefficient for a given implementation, this method should be
            overridden.
            </summary>
            <returns>A semi-unique hash integer.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.ConnectionDescriptor.GetDecryptedConfigParameter(Azavea.Open.Common.Config,System.String,System.String,Azavea.Open.DAO.ConnectionInfoDecryptionDelegate)">
            <summary>
            This method is provided for convenience.  If decryptionDelegate is not null,
            will use it to decrypt whatever value is in the config parameter.
            </summary>
            <param name="config">Config file to get the parameter from.</param>
            <param name="component">Section within the config file.</param>
            <param name="paramName">Name of the paraneter within the section.</param>
            <param name="decryptionDelegate">Method to call to decrypt the parameter.  May be null if using plain text.</param>
            <returns></returns>
        </member>
        <member name="T:Azavea.Open.DAO.ConnectionInfoDecryptionDelegate">
            <summary>
            Connection descriptors may support having the connection info stored in the
            configuration file in an encrypted format (particularly passwords).  Depending
            on the system this may or may not provide actual security benefits, but often
            makes people feel better.
            
            This is the delegate that the connection descriptor uses to decrypt any encrypted
            information (what the descriptor supports having encrypted depends on the
            implementation, typically it is just password fields).
            </summary>
            <param name="input">Encrypted info from the config file.</param>
            <returns>The same info in plain text.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression">
            <summary>
            Base class for group expressions.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression.Name">
            <summary>
            Name of the grouping, I.E. this is what shows up as
            a key in the dictionary in the GroupCountResult.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression.#ctor(System.String)">
            <summary>
            Initializes the grouping expression with its name.
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Grouping.GroupCountSortOrder">
            <summary>
            This can be used to indicate you want to sort based on the count
            in a count where you're aggregating values.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.SortOrder">
            <summary>
            A simple class that holds a single sort criterion.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.SortOrder.Property">
            <summary>
            The data class' property to sort on.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.SortOrder.Direction">
            <summary>
            The direction to sort based on the Property.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.SortOrder.#ctor(System.String)">
            <summary>
            A simple class that holds a single sort criterion.
            This constructor constructs one with an "ascending" sort.
            </summary>
            <param name="property">The data class' property to sort on.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.SortOrder.#ctor(System.String,Azavea.Open.DAO.Criteria.SortType)">
            <summary>
            A simple class that holds a single sort criterion.
            </summary>
            <param name="property">The data class' property to sort on.</param>
            <param name="direction">The direction to sort based on the Property.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.SortOrder.ToString">
            <summary>
            
                                Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                            
            </summary>
            
            <returns>
            
                                A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                            
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Grouping.GroupCountSortOrder.#ctor">
            <summary>
            Default sort order is ascending.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Grouping.GroupCountSortOrder.#ctor(Azavea.Open.DAO.Criteria.SortType)">
            <summary>
            Lets you specify the sort direction.
            </summary>
            <param name="direction">Do you want counts going up or down?</param>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Grouping.MemberGroupExpression">
            <summary>
            A group expression that aggregates based on values of a data member.
            This is the most common case.  I.E. aggregating based on a "Type"
            field or property on the data object.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Grouping.MemberGroupExpression.MemberName">
            <summary>
            The name of the data member (field/property) on the object to
            group by.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Grouping.MemberGroupExpression.#ctor(System.String)">
            <summary>
            Creates the expression using the member name as the group name.
            </summary>
            <param name="memberName">The name of the data member (field/property) on the object to
                                     group by.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Grouping.MemberGroupExpression.#ctor(System.String,System.String)">
            <summary>
            Create the expression with an explicit name to use instead of the data member name
            when including it in the GroupCountResult.
            </summary>
            <param name="memberName">The name of the data member (field/property) on the object to
                                     group by.</param>
            <param name="groupName">The name to call it in the GroupCountResult's collection.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.TransactionsNotSupportedException">
            <summary>
            This exception is thrown when trying to use a transaction with a connection
            that doesn't support them.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.ExceptionWithConnectionInfo">
            <summary>
            This exception type is constructed with the database connection string
            as part of the message.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.ExceptionWithConnectionInfo.#ctor(System.String,Azavea.Open.DAO.IConnectionDescriptor,System.Exception)">
            <summary>
            An error occurred doing something with a database.
            </summary>
            <param name="message">What happened.</param>
            <param name="desc">The connection info will be appended to the message.</param>
            <param name="e">Inner exception that caused this one to be thrown.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.TransactionsNotSupportedException.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.String)">
            <summary>
            This connection doesn't support transactions.
            </summary>
            <param name="desc">Connection descriptor we were using to try to connect.</param>
            <param name="message">A message describing what is wrong with the connection type.</param>
        </member>
        <member name="T:Azavea.Open.DAO.GroupCountResult">
            <summary>
            Represents the results from a count of records grouped (aggregated) by some
            field or fields.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.GroupCountResult.Count">
            <summary>
            The number of results found with this combination of group values.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.GroupCountResult.GroupValues">
            <summary>
            The combination of group values that occurs Count times in the
            data source.  Group values are a single set of unique values
            for the fields you grouped by, with key being the name of the
            grouping and value being the value (I.E. key is "Type" value is "1"
            and key is "FirstName" value is "Bob", Count would then be the
            number of records in the data source with a Type of "1" and a
            FirstName of "Bob".
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.GroupCountResult.#ctor(System.Int32,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Creates the result.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.IDaDdlLayer">
            <summary>
            Some data access layers may optionally implement "DDL" tasks (creating and
            destroying data sources, indexing the data, etc).  If so, they will implement
            this interface.
            
            Documentation for each particular data access layer should be explicit about
            which methods are implemented vs. which ones throw NotImplementedExceptions,
            since some methods may be impractical to implement on certain data sources.
            
            House vs. Room Metaphor:  Some data sources are capable of storing more than
            one type of data (I.E. multiple tables in a database).  These correspond to
            "rooms".  Some data sources are capable of storing multiple groups of "rooms"
            in one data source, I.E. multiple "databases" on a single server.
            
            IConnectionDescriptors typically point at a single StoreHouse, but may be used
            with multiple FastDAOs to store different types of data in different StoreRooms.
            
            Examples:
                         House        Room
            Oracle       N/A          Table
            SQL Server   Database     Table
            CSV          N/A          File
            SQLite       File         Table
            
            Implementors of this should ask themselves "What if someone switched to a different
            data access layer, would they have to change their code?"  In other words, make the
            methods that don't apply act as sensibly as possible.  Examples are given in the
            descriptions of the specific methods.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.CreateIndex(System.String,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Indexes the data for faster queries.  Some data sources may not support indexes
            (such as CSV files), in which case this should throw a NotSupportedException.
            
            If the data source supports indexes, but support for creating them is not yet
            implemented, this should throw a NotImplementedException.
            </summary>
            <param name="name">Name of the index.  Some data sources require names for indexes,
                               and even if not this is required so the index can be deleted if desired.</param>
            <param name="mapping">ClassMapping for the data that is being indexed.</param>
            <param name="propertyNames">Names of the data properties to include in the index (in order).</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.DeleteIndex(System.String,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Removes an index on the data for slower queries (but usually faster inserts/updates/deletes).
            Some data sources may not support indexes (such as CSV files), 
            in which case this method should be a no-op.
            
            If the data source supports indexes, but support for deleting them is not yet
            implemented, this should throw a NotImplementedException.
            
            If there is no index with the given name, this should be a no-op.
            </summary>
            <param name="name">Name of the index to delete.</param>
            <param name="mapping">ClassMapping for the data that was being indexed.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.IndexExists(System.String,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Returns whether an index with this name exists or not.  NOTE: This does NOT
            verify what properties the index is on, merely whether an index with this
            name is already present.
            </summary>
            <param name="name">Name of the index to check for.</param>
            <param name="mapping">ClassMapping for the data that may be indexed.</param>
            <returns>Whether an index with this name exists in the data source.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.CreateSequence(System.String)">
            <summary>
            Sequences are things that automatically generate unique, usually incrementing,
            numbers.  Some data sources may not support sequences, in which case this should
            throw a NotSupportedException.
            
            If the data source supports sequences, but support for creating them is not yet
            implemented, this should throw a NotImplementedException.
            </summary>
            <param name="name">Name of the new sequence to create.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.DeleteSequence(System.String)">
            <summary>
            Removes a sequence.  Some data sources may not support sequences, 
            in which case this method should be a no-op.
            
            If the data source supports sequences, but support for deleting them is not yet
            implemented, this should throw a NotImplementedException.
            
            If there is no sequence with the given name, this should be a no-op.
            </summary>
            <param name="name">Name of the sequence to delete.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.SequenceExists(System.String)">
            <summary>
            Returns whether a sequence with this name exists or not.
            </summary>
            <param name="name">Name of the sequence to check for.</param>
            <returns>Whether a sequence with this name exists in the data source.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.CreateStoreHouse">
            <summary>
            Creates the store house specified in the connection descriptor.  If this
            data source doesn't use a store house, this method should be a no-op.
            
            If this data source DOES use store houses, but support for adding
            them is not implemented yet, this should throw a NotImplementedException.
            
            Store house typically corresponds to "database".
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.DeleteStoreHouse">
            <summary>
            Deletes the store house specified in the connection descriptor.  If this
            data source doesn't use a store house, this method should be a no-op.
            
            If this data source DOES use store houses, but support for dropping
            them is not implemented yet, this should throw a NotImplementedException.
            
            Store house typically corresponds to "database".
            
            If there is no store house with the given name, this should be a no-op.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.StoreHouseMissing">
            <summary>
            Returns true if you need to call "CreateStoreHouse" before storing any
            data.  This method is "Missing" not "Exists" because implementations that
            do not use a store house (I.E. single-file-based data access layers) can
            return "false" from this method without breaking either a user's app or the
            spirit of the method.
            
            Store house typically corresponds to "database".
            </summary>
            <returns>Returns true if you need to call "CreateStoreHouse"
                     before storing any data.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.CreateStoreRoom(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Creates the store room specified in the connection descriptor.  If this
            data source doesn't use a store room, this method should be a no-op.
            
            If this data source DOES use store rooms, but support for adding
            them is not implemented yet, this should throw a NotImplementedException.
            
            Store room typically corresponds to "table".
            </summary>
            <param name="mapping">ClassMapping for the data that will be stored in this room.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.DeleteStoreRoom(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Deletes the store room specified in the connection descriptor.  If this
            data source doesn't use a store room, this method should be a no-op.
            
            If this data source DOES use store rooms, but support for adding
            them is not implemented yet, this should throw a NotImplementedException.
            
            Store room typically corresponds to "table".
            
            If there is no store room with the given name, this should be a no-op.
            </summary>
            <param name="mapping">ClassMapping for the data that was stored in this room.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.StoreRoomMissing(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Returns true if you need to call "CreateStoreRoom" before storing any
            data.  This method is "Missing" not "Exists" because implementations that
            do not use a store room can return "false" from this method without
            breaking either a user's app or the spirit of the method.
            
            Store room typically corresponds to "table".
            </summary>
            <param name="mapping">ClassMapping for the data that is stored in this room.</param>
            <returns>Returns true if you need to call "CreateStoreRoom"
                     before storing any data.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaDdlLayer.GenerateClassMappingFromStoreRoom(System.String,System.Collections.Generic.IComparer{Azavea.Open.DAO.ClassMapColDefinition})">
            <summary>
            Uses some form of introspection to determine what data is stored in
            this data store, and generates a ClassMapping that can be immediately
            used with a DictionaryDAO.  As much data as practical will be populated
            on the ClassMapping, at a bare minimum the Table (typically set to
            the storeRoomName passed in, or the more correct or fully qualified version
            of that name), the TypeName (set to the storeRoomName, since we have no
            .NET type), and the "data cols" and "obj attrs" will be the list of 
            attributes / columns in the data source, mapped to themselves.
            </summary>
            <param name="storeRoomName">The name of the storeroom (I.E. table).  May be null
                                        if this data source does not use store rooms.</param>
            <param name="columnSorter">If you wish the columns / attributes to be in a particular
                                       order, supply this optional parameter.  May be null.</param>
            <returns>A ClassMapping that can be used with a DictionaryDAO.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.ITransaction">
            <summary>
            Represents a transaction (a guarauntee that a series of operations are
            executed against a connection without any other operations from other
            connections interfering).
            
            NOTE: You MUST call Commit or Rollback when done!  If you do not, the destructor
            (assuming a nice shutdown where the destructor is called) will attempt to call
            Rollback, however this is just a "nice" attempt to clean up, and will not happen
            until the garbage collector collects this object, so it should not be relied upon.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.ITransaction.Commit">
            <summary>
            Writes all the statements executed as part of this transaction to the
            database.  Until this is called, none of the inserts/updates/deletes
            you do will be visible to any other users of the database.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.ITransaction.Rollback">
            <summary>
            Undoes all the statements executed as part of this transaction.  The
            database will be as though you never executed them.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.ITransactionalConnectionDescriptor">
            <summary>
            If the data source supports transactions (multiple operations as an atomic unit)
            (such as most databases) the connection descriptor will implement this interface.
            
            Usage: First call BeginTransaction, then pass the ITransaction
                   it gives you to every subsequent FastDAO call (if you call a method but
                   do not pass the ITransaction, the method will not happen as part
                   of this transaction).  When complete, call Commit (or Rollback if
                   something went wrong).
            
            NOTE: Since it is now up to you to complete the transaction, this is likely no longer threadsafe.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.ITransactionalConnectionDescriptor.BeginTransaction">
            <summary>
            Begins the transaction.  Returns a transaction object that you should
            use for operations you wish to be part of the transaction.
            
            NOTE: You MUST call Commit or Rollback on the returned ITransaction when you are done.
            </summary>
            <returns>The Transaction object to pass to calls that you wish to have
                     happen as part of this transaction.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.DictionaryDao">
            <summary>
            A FastDAO that returns Dictionaries instead of objects.  This is a more
            basic DAO that is useful in cases where you don't actually care much about
            the object (I.E. are just going to drop it into XML or JSON anyway or
            something like that).
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.FastDAO`1">
            <summary>
            This class is built to be a "fast and easy" way of reading/writing objects to/from a
            data source.  It is meant to have high performance on throughput of large numbers of objects.
            It does not support every possible sophistication that an ORM system can have.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.IFastDaoInserter`1">
            <summary>
            This interface defines the "insert" methods of FastDAO.
            </summary>
            <typeparam name="T">The type of object that can be written.</typeparam>
        </member>
        <member name="T:Azavea.Open.DAO.IFastDaoBase`1">
            <summary>
            This interface defines the most basic methods on a FastDAO, regardless of which
            interfaces it implements.
            </summary>
            <typeparam name="T">The type of object that can be deleted.</typeparam>
        </member>
        <member name="P:Azavea.Open.DAO.IFastDaoBase`1.ClassMap">
            <summary>
            The ClassMapping object representing the class-to-record mapping 
            to use with the data source.
            </summary>
        </member>
        <member name="P:Azavea.Open.DAO.IFastDaoBase`1.ConnDesc">
            <summary>
            The object describing how to connect to and/or interact with the data
            source we're reading objects from.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoInserter`1.Insert(`0,System.Boolean)">
            <summary>
            Inserts this object as a new record/row/line/etc. in the data source.
            </summary>
            <param name="obj">The object to write.</param>
            <param name="setGeneratedId">Update the object with its new ID if the ID was 
                                         autogenerated by the database.  Depending on the implementation,
                                         that may requires a query to retrieve the ID, and "most" of the 
                                         time you don't need the ID (you insert the object and then are
                                         done with it) so there is an advantage to not retrieving the ID
                                         if not necessary.  Not all data sources support retrieving a
                                         generated ID.
                                         If setGeneratedId is false, this ONLY sets the 
                                         object's ID field(s) IF the implementation of the auto-generation
                                         requires us to obtain the ID before writing to the data source.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoInserter`1.Insert(Azavea.Open.DAO.ITransaction,`0,System.Boolean)">
            <summary>
            Inserts this object as a new record/row/line/etc. in the data source.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="obj">The object to write.</param>
            <param name="setGeneratedId">Update the object with its new ID if the ID was 
                                         autogenerated by the database.  Depending on the implementation,
                                         that may requires a query to retrieve the ID, and "most" of the 
                                         time you don't need the ID (you insert the object and then are
                                         done with it) so there is an advantage to not retrieving the ID
                                         if not necessary.  Not all data sources support retrieving a
                                         generated ID.
                                         If setGeneratedId is false, this ONLY sets the 
                                         object's ID field(s) IF the implementation of the auto-generation
                                         requires us to obtain the ID before writing to the data source.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoInserter`1.Insert(`0)">
            <summary>
            Same as calling Insert(obj, false);
            </summary>
            <param name="obj">The object to write.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoInserter`1.Insert(Azavea.Open.DAO.ITransaction,`0)">
            <summary>
            Same as calling Insert(obj, false);
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="obj">The object to write.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoInserter`1.Insert(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a bunch of records, hopefully faster than
            separate calls to Insert().  Whether it is actually faster depends on
            the implementation.
            </summary>
            <param name="insertUs">List of objects to insert.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoInserter`1.Insert(Azavea.Open.DAO.ITransaction,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a bunch of records, hopefully faster than
            separate calls to Insert().  Whether it is actually faster depends on
            the implementation.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="insertUs">List of objects to insert.</param>
        </member>
        <member name="T:Azavea.Open.DAO.IFastDaoUpdater`1">
            <summary>
            This interface defines the "update" methods of a FastDAO.
            </summary>
            <typeparam name="T">The type of object that can be written.</typeparam>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoUpdater`1.Update(`0)">
            <summary>
            Updates this object's record in the data source.
            </summary>
            <param name="obj">The object to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoUpdater`1.Update(Azavea.Open.DAO.ITransaction,`0)">
            <summary>
            Updates this object's record in the data source.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="obj">The object to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoUpdater`1.Update(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Updates a bunch of records, hopefully faster than
            separate calls to Update().  Whether it is actually faster depends on
            the implementation.
            </summary>
            <param name="updateUs">List of objects to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoUpdater`1.Update(Azavea.Open.DAO.ITransaction,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Updates a bunch of records, hopefully faster than
            separate calls to Update().  Whether it is actually faster depends on
            the implementation.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="updateUs">List of objects to save.</param>
        </member>
        <member name="T:Azavea.Open.DAO.IFastDaoDeleter`1">
            <summary>
            This interface defines the "delete" methods of FastDAO.
            </summary>
            <typeparam name="T">The type of object that can be deleted.</typeparam>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoDeleter`1.Delete(`0)">
            <summary>
            Deletes the specified object from the data source.  No error is generated
            if the object does not appear to be stored in the data source.
            </summary>
            <param name="dataObject">An object to delete from the data source.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoDeleter`1.Delete(Azavea.Open.DAO.ITransaction,`0)">
            <summary>
            Deletes the specified object from the data source.  No error is generated
            if the object does not appear to be stored in the data source.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="dataObject">An object to delete from the data source.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoDeleter`1.Delete(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Deletes the specified objects from the data source.  If the objects are not in the
            database, no error is generated.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoDeleter`1.Delete(Azavea.Open.DAO.ITransaction,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Deletes the specified objects from the data source.  If the objects are not in the
            database, no error is generated.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoDeleter`1.Delete(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Deletes objects from the data source that meet the given criteria.
            </summary>
            <param name="crit">Criteria for deletion.  NOTE: Only the expressions are observed,
                               other things (like "order" or start / limit) are ignored.
                               Also, null or blank (no expressions) criteria are NOT allowed.
                               If you really wish to delete all rows, call DeleteAll().</param>
            <returns>The number of rows/objects deleted (or UNKNOWN_NUM_ROWS).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoDeleter`1.Delete(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Deletes objects from the data source that meet the given criteria.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">Criteria for deletion.  NOTE: Only the expressions are observed,
                               other things (like "order" or start / limit) are ignored.
                               Also, null or blank (no expressions) criteria are NOT allowed.
                               If you really wish to delete all rows, call DeleteAll().</param>
            <returns>The number of rows/objects deleted (or UNKNOWN_NUM_ROWS).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoDeleter`1.DeleteAll">
            <summary>
            Deletes all records of this dao's type.
            </summary>
            <returns>The number of rows/objects deleted.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoDeleter`1.DeleteAll(Azavea.Open.DAO.ITransaction)">
            <summary>
            Deletes all records of this dao's type.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <returns>The number of rows/objects deleted.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoDeleter`1.Truncate">
            <summary>
            Deletes every row from the data source for this DAO.  
            Can be faster than DeleteAll for certain types of data source
            and/or certain conditions, but requires greater permissions.
            If the data source does not support truncation, this will be
            exactly the same as calling DeleteAll().
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.IFastDaoReader`1">
            <summary>
            This interface defines the "query" methods of FastDAO.
            </summary>
            <typeparam name="T">The type of object that can be written.</typeparam>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Get">
            <summary>
            Returns all objects of the given type.
            </summary>
            <returns>A list of objects, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Get(Azavea.Open.DAO.ITransaction)">
            <summary>
            Returns all objects of the given type.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <returns>A list of objects, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Get(System.String,System.Object)">
            <summary>
            Queries for objects where the property matches the given value.
            </summary>
            <param name="propertyName">Property or Field on the object you want to match a value.</param>
            <param name="propertyValue">Value that the Property or Field should have.</param>
            <returns>All objects that match the criteria, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Get(Azavea.Open.DAO.ITransaction,System.String,System.Object)">
            <summary>
            Queries for objects where the property matches the given value.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="propertyName">Property or Field on the object you want to match a value.</param>
            <param name="propertyValue">Value that the Property or Field should have.</param>
            <returns>All objects that match the criteria, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Get(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Queries and returns objects of the specified type matching the criteria.
            </summary>
            <param name="crit">The criteria that you wish the objects to match.  You can also
                               specify a start/limit, ordering, etc.</param>
            <returns>A list of objects, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Get(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Queries and returns objects of the specified type matching the criteria.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">The criteria that you wish the objects to match.  You can also
                               specify a start/limit, ordering, etc.</param>
            <returns>A list of objects, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Get``1(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0})">
            <summary>
            Performs a join, or the nearest possible equivilent depending on the data sources
            involved, and returns the results.  If you aren't familiar with joins, do some reading
            online.  This should behave like a "normal" database SQL join on all data sources.
            
            When "joining" DAOs that are operating on different data sources, or data sources
            with no inherent join support (flat files for example), joins will be performed
            using the "PseudoJoiner" class, see that class for more details.
            </summary>
            <param name="crit">An object describing how to join the two DAOs.  Includes any
                               criteria that apply to the right or left DAO.</param>
            <param name="rightDao">The other DAO we are joining against.</param>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <returns>A list of JoinResults, containing the matching objects from each DAO.  This is similar
                     to the way that </returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Get``1(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0})">
            <summary>
            Performs a join, or the nearest possible equivilent depending on the data sources
            involved, and returns the results.  If you aren't familiar with joins, do some reading
            online.  This should behave like a "normal" database SQL join on all data sources.
            
            When "joining" DAOs that are operating on different data sources, or data sources
            with no inherent join support (flat files for example), joins will be performed
            using the "PseudoJoiner" class, see that class for more details.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">An object describing how to join the two DAOs.  Includes any
                               criteria that apply to the right or left DAO.</param>
            <param name="rightDao">The other DAO we are joining against.</param>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <returns>A list of JoinResults, containing the matching objects from each DAO.  This is similar
                     to the way that </returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.GetCount(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Returns the number of objects of the specified type matching the given criteria.
            </summary>
            <param name="crit">The criteria that you wish the objects to match.  Start/limit and order are ignored.</param>
            <returns>The number of objects that match the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Returns the number of objects of the specified type matching the given criteria.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">The criteria that you wish the objects to match.  Start/limit and order are ignored.</param>
            <returns>The number of objects that match the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.GetCount(Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression})">
            <summary>
            Returns the number of objects of the specified type matching the given criteria,
            aggregated by the given grouping expressions.  This matches "GROUP BY" behavior
            in SQL.
            </summary>
            <param name="crit">The criteria that you wish the objects to match.  Start/limit and order are ignored.</param>
            <param name="groupExpressions">The fields/expressions to aggregate on when counting.</param>
            <returns>The number of objects that match the criteria, plus the values of those objects
                     for the fields that were aggregated on.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression})">
            <summary>
            Returns the number of objects of the specified type matching the given criteria,
            aggregated by the given grouping expressions.  This matches "GROUP BY" behavior
            in SQL.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">The criteria that you wish the objects to match.  Start/limit and order are ignored.</param>
            <param name="groupExpressions">The fields/expressions to aggregate on when counting.</param>
            <returns>The number of objects that match the criteria, plus the values of those objects
                     for the fields that were aggregated on.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.GetCount``1(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0})">
            <summary>
            Performs a join using the given join criteria and returns the number of rows that
            result from the join.
            </summary>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <param name="crit">An object describing how to join the two DAOs.  Includes any
                               criteria that apply to the right or left DAO.</param>
            <param name="rightDao">The other DAO we are joining against.</param>
            <returns>The number of join results that matched the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.GetCount``1(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0})">
            <summary>
            Performs a join using the given join criteria and returns the number of rows that
            result from the join.
            </summary>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">An object describing how to join the two DAOs.  Includes any
                               criteria that apply to the right or left DAO.</param>
            <param name="rightDao">The other DAO we are joining against.</param>
            <returns>The number of join results that matched the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.GetFirst(System.String,System.Object)">
            <summary>
            Queries for objects where the property matches the given value.
            </summary>
            <param name="propName">Property or Field on the object you want to match a value.</param>
            <param name="val">Value that the Property or Field should have.</param>
            <returns>The first object that matches the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.GetFirst(Azavea.Open.DAO.ITransaction,System.String,System.Object)">
            <summary>
            Queries for objects where the property matches the given value.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="propName">Property or Field on the object you want to match a value.</param>
            <param name="val">Value that the Property or Field should have.</param>
            <returns>The first object that matches the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Iterate``1(Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.DaoIterationDelegate{`0,``0},``0,System.String)">
            <summary>
            Queries for objects, similar to Get, except that this iterates over the resulting
            records and invokes the specified delegate for each one.  This allows processing of much
            larger result sets since it doesn't attempt to load all the objects into memory at once.
            </summary>
            <typeparam name="P">The type of the 'parameters' object taken by the delegate.</typeparam>
            <param name="criteria">Any criteria for the query.  May be null for "all records".</param>
            <param name="invokeMe">The method to invoke for each object returned by the query.</param>
            <param name="parameters">Any parameters that you want to pass to the invokeMe method.
                                       This may be null.</param>
            <param name="desc">Description of the loop for logging purposes.</param>
            <returns>The number of objects iterated over.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.Iterate``1(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.DaoIterationDelegate{`0,``0},``0,System.String)">
            <summary>
            Queries for objects, similar to Get, except that this iterates over the resulting
            records and invokes the specified delegate for each one.  This allows processing of much
            larger result sets since it doesn't attempt to load all the objects into memory at once.
            </summary>
            <typeparam name="P">The type of the 'parameters' object taken by the delegate.</typeparam>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="criteria">Any criteria for the query.  May be null for "all records".</param>
            <param name="invokeMe">The method to invoke for each object returned by the query.</param>
            <param name="parameters">Any parameters that you want to pass to the invokeMe method.
                                       This may be null.</param>
            <param name="desc">Description of the loop for logging purposes.</param>
            <returns>The number of objects iterated over.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IFastDaoReader`1.GetValueFromObject(`0,System.String)">
            <summary>
            Gets a single value off the data object based on the
            name of the field/property.
            </summary>
            <param name="dataObject">The object to get a value off of.</param>
            <param name="fieldName">The name of the field/property to get the value of.</param>
            <returns>The value.</returns>
        </member>
        <member name="F:Azavea.Open.DAO.FastDAO`1.UNKNOWN_NUM_ROWS">
            <summary>
            This is the value that will be returned from methods that return a number of rows
            affected, if the number is unable to be determined.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.FastDAO`1._log">
            <summary>
            log4net logger that any child class may use for logging any appropriate messages.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.FastDAO`1._connDesc">
            <summary>
            The connection descriptor created from the connection config parameters.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.FastDAO`1._classMap">
            <summary>
            The ClassMapping object representing the class-to-table mapping 
            loaded from the config file.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.FastDAO`1._dataAccessLayer">
            <summary>
            The data access layer can be different depending on what kind of data source we're talking to.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.#ctor(System.String,System.String)">
            <summary>
            This allows you to specify the config name and the section in the config file
            used to get the database config info.
            </summary>
            <param name="configName">Name used to get the configuration.</param>
            <param name="sectionName">Name of the section within the config file.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.#ctor(System.String,System.String,Azavea.Open.DAO.ConnectionInfoDecryptionDelegate)">
            <summary>
            This allows you to specify the config name and the section in the config file
            used to get the database config info.
            </summary>
            <param name="configName">Name used to get the configuration.</param>
            <param name="sectionName">Name of the section within the config file.</param>
            <param name="decryptionDelegate">The method to call to decrypt passwords or
                                             other encrypted connection info.  May be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.#ctor(Azavea.Open.Common.Config,System.String)">
            <summary>
            This allows you to give the config object and the section in the config
            used to get the database config info.
            </summary>
            <param name="config">Configuration object (presumably read ahead of time).</param>
            <param name="sectionName">Name of the section within the config.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.#ctor(Azavea.Open.Common.Config,System.String,Azavea.Open.DAO.ConnectionInfoDecryptionDelegate)">
            <summary>
            This allows you to give the config object and the section in the config
            used to get the database config info.
            </summary>
            <param name="config">Configuration object (presumably read ahead of time).</param>
            <param name="sectionName">Name of the section within the config.</param>
            <param name="decryptionDelegate">The method to call to decrypt passwords or
                                             other encrypted connection info.  May be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.String)">
            <summary>
            This allows you to specify the data source connection info and the mapping file.
            </summary>
            <param name="connDesc">DB Connection information.</param>
            <param name="mappingFileName">Filename (with path) to the mapping file.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.#ctor(Azavea.Open.DAO.IConnectionDescriptor,Azavea.Open.DAO.ClassMapping)">
            <summary>
            If you already have the DB connection and the mapping information, you may use
            this constructor.
            </summary>
            <param name="connDesc">DB Connection information.</param>
            <param name="mapping">ClassMapping describing the class to be mapped and
                                  the table to map it to.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.ParseHibernateConfig(System.Type,System.String)">
            <summary>
            Loads ClassMappings from NHibernate config xml.  This method is somewhat
            fragile (doesn't catch exceptions), since if we can't parse the NHibernate
            config, we can't do much.  However it will ignore problems with class mappings
            other than for the desired type.
            
            Static so we can call it from the constructor.
            </summary>
            <param name="desiredType">The type we're loading a mapping for.</param>
            <param name="fileName">XML File containing an NHibernate configuration.</param>
            <returns>The class mapping for the desired type.  If unable to find it, an
                     exception is thrown, so you may safely assume this will never return
                     null.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.ParseHibernateConfig(System.Type,System.String,System.String)">
            <summary>
            Loads ClassMappings from NHibernate config xml.  This method is somewhat
            fragile (doesn't catch exceptions), since if we can't parse the NHibernate
            config, we can't do much.  However it will ignore problems with class mappings
            other than for the desired type.
            
            Static so we can call it from the constructor.
            </summary>
            <param name="desiredType">The type we're loading a mapping for.</param>
            <param name="xmlStr">The XML text that contains the NHibernate-style XML configuration.</param>
            <param name="xmlSource">Where the XML came from, I.E. a filename or other explaination
                                    you would like to see in an error message.  Used only for exception
                                    message, may be null.</param>
            <returns>The class mapping for the desired type.  If unable to find it, an
                     exception is thrown, so you may safely assume this will never return
                     null.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.ParseHibernateConfig(System.Type,System.Xml.XmlNode,System.String)">
            <summary>
            Loads ClassMappings from NHibernate config xml.  This method is somewhat
            fragile (doesn't catch exceptions), since if we can't parse the NHibernate
            config, we can't do much.  However it will ignore problems with class mappings
            other than for the desired type.
            
            Static so we can call it from the constructor.
            </summary>
            <param name="desiredType">The type we're loading a mapping for.</param>
            <param name="xml">The XML node that contains the NHibernate-style XML configuration.</param>
            <param name="xmlSource">Where the XML came from, I.E. a filename or other explaination
                                    you would like to see in an error message.  Used only for exception
                                    message, may be null.</param>
            <returns>The class mapping for the desired type.  If unable to find it, an
                     exception is thrown, so you may safely assume this will never return
                     null.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetClassNodes(System.Xml.XmlNode)">
            <summary>
            After some experimentation, it was determined that using a manual recursive
            function to find all the 'class' nodes is fastest, GetElementsByTagName is
            almost 3x slower (and only works on XmlDocuments not XmlNodes anyway) and 
            SelectNodes is 2.5x slower than GetElementsByTagName.
            </summary>
            <param name="node">Top node of the tree where we're looking for class nodes.</param>
            <returns>A list of all the class nodes in this xml tree.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.AddCoercibleType(System.Type,Azavea.Open.DAO.TypeCoercionDelegate)">
            <summary>
            A method to add a coercion delegate for a type.  This allows you to specify how
            to convert an unsupported type to/from the data source.
            </summary>
            <param name="t">The type to coerce.</param>
            <param name="coercionDelegate">How to coerce it.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Delete(`0)">
            <summary>
            Deletes the specified object from the data source.
            </summary>
            <param name="dataObject">An object to delete from the DB.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Delete(Azavea.Open.DAO.ITransaction,`0)">
            <summary>
            Deletes the specified object from the data source.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="dataObject">An object to delete from the DB.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Delete(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Deletes the specified objects from the data source.  If the objects are not in the
            data source, it ignores them.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Delete(Azavea.Open.DAO.ITransaction,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Deletes the specified objects from the data source.  If the objects are not in the
            data source, it ignores them.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Delete(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Deletes objects from the data source that meet the given criteria.
            </summary>
            <param name="crit">Criteria for deletion.  NOTE: Only the expressions are observed,
                               other things (like "order" or start / limit) are ignored.
                               Also, null or blank (no expressions) criteria are NOT allowed.
                               If you really wish to delete everything, call DeleteAll().</param>
            <returns>The number of rows/objects deleted (or UNKNOWN_NUM_ROWS).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Delete(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Deletes objects from the data source that meet the given criteria.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">Criteria for deletion.  NOTE: Only the expressions are observed,
                               other things (like "order" or start / limit) are ignored.
                               Also, null or blank (no expressions) criteria are NOT allowed.
                               If you really wish to delete everything, call DeleteAll().</param>
            <returns>The number of rows/objects deleted (or UNKNOWN_NUM_ROWS).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.DeleteAll">
            <summary>
            Deletes all records of this dao's type.
            </summary>
            <returns>The number of rows/objects deleted.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.DeleteAll(Azavea.Open.DAO.ITransaction)">
            <summary>
            Deletes all records of this dao's type.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <returns>The number of rows/objects deleted.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Truncate">
            <summary>
            Deletes every row from the table for this DAO.
            Performance will be equal to or better than DeleteAll, but may require
            that the user (from the connection descriptor) have greater permissions
            than necessary for DeleteAll.  Depends on the implementation.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Save(`0)">
            <summary>
            Tries to update the object if it is already in the DB, which it guesses by calling
            IsIDValid on it and/or by just trying tye update and seeing if it works, otherwise
            inserts it as a new record.
            
            NOTE: If you already know whether you're going to be doing an insert or an update,
            calling Insert() or Update() will be faster.
            </summary>
            <param name="obj">The object to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Save(`0,System.Boolean)">
            <summary>
            Overload for Save that allows us to put the generated ID into the object if inserting
            to a table with a DB-generated ID column.
            </summary>
            <param name="obj"></param>
            <param name="setGeneratedId">Whether to set the generated ID on the
                                         object to be saved.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Insert(`0,System.Boolean)">
            <summary>
            Faster than Save if you know this is a new object that is being inserted.
            Inserts the object into the data source.  If there are unique constraints on
            the data source and this is a duplicate record, this may generate an error.
            </summary>
            <param name="obj">The object to save.</param>
            <param name="setGeneratedId">Update the object with its new ID if the ID was 
                                         autogenerated by the database.  That requires a 
                                         second DB query to retrieve the ID and "most" of the 
                                         time you may not need it.
                                         If setGeneratedId is false, this ONLY Updates the 
                                         object's ID field(s) IF the mapping contains a sequence, 
                                         meaning that FastDAO must query the sequence for the next 
                                         value anyway.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Insert(Azavea.Open.DAO.ITransaction,`0,System.Boolean)">
            <summary>
            Faster than Save if you know this is a new object that is being inserted.
            Inserts the object into the data source.  If there are unique constraints on
            the data source and this is a duplicate record, this may generate an error.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="obj">The object to save.</param>
            <param name="setGeneratedId">Update the object with its new ID if the ID was 
                                         autogenerated by the database.  That requires a 
                                         second DB query to retrieve the ID and "most" of the 
                                         time you may not need it.
                                         If setGeneratedId is false, this ONLY Updates the 
                                         object's ID field(s) IF the mapping contains a sequence, 
                                         meaning that FastDAO must query the sequence for the next 
                                         value anyway.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Insert(`0)">
            <summary>
            Simpler override, same as calling Insert(obj, false);
            </summary>
            <param name="obj">The object to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Insert(Azavea.Open.DAO.ITransaction,`0)">
            <summary>
            Simpler override, same as calling Insert(obj, false);
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="obj">The object to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Insert(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a bunch of records, hopefully to be faster than
            separate calls to Insert().  Whether it is or not depends on the implementation.
            </summary>
            <param name="insertUs">List of objects to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Insert(Azavea.Open.DAO.ITransaction,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a bunch of records, hopefully to be faster than
            separate calls to Insert().  Whether it is or not depends on the implementation.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="insertUs">List of objects to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Update(`0)">
            <summary>
            Faster than Save if you know this is an existing object that is being updated.
            Updates the data source with the new values from this object.  May generate an
            error if the object does not in fact exist in the data source yet.
            </summary>
            <param name="obj">The object to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Update(Azavea.Open.DAO.ITransaction,`0)">
            <summary>
            Faster than Save if you know this is an existing object that is being updated.
            Updates the data source with the new values from this object.  May generate an
            error if the object does not in fact exist in the data source yet.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="obj">The object to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Update(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Updates a bunch of records, hopefully to be faster than
            separate calls to Update().  Whether it is or not depends on the implementation.
            </summary>
            <param name="updateUs">List of objects to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Update(Azavea.Open.DAO.ITransaction,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Updates a bunch of records, hopefully to be faster than
            separate calls to Update().  Whether it is or not depends on the implementation.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="updateUs">List of objects to save.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.UpdateColumn(Azavea.Open.DAO.Criteria.DaoCriteria,System.String,System.Object)">
            <summary>
            Updates a single column on a bunch of records, hopefully to be easier than separate
            calls to Get() and Update().  Whether it is faster or not depends on the implementation.
            </summary>
            <param name="criteria">The criteria specifying which objects to update. May be null</param>
            <param name="propName">The property or field to be modified</param>
            <param name="value">The new value for the property</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Get">
            <summary>
            Returns all objects of the given type.
            </summary>
            <returns>A list of objects, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Get(Azavea.Open.DAO.ITransaction)">
            <summary>
            Returns all objects of the given type.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <returns>A list of objects, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetFirst(System.String,System.Object)">
            <summary>
            Queries for objects of the specified type where the property matches the given value.
            </summary>
            <param name="propName">Property or Field on the object you want to match a value.</param>
            <param name="val">Value that the Property or Field should have.</param>
            <returns>The first object that matches the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetFirst(Azavea.Open.DAO.ITransaction,System.String,System.Object)">
            <summary>
            Queries for objects of the specified type where the property matches the given value.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="propName">Property or Field on the object you want to match a value.</param>
            <param name="val">Value that the Property or Field should have.</param>
            <returns>The first object that matches the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetFirst(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Queries for one object that matches the given criteria.
            </summary>
            <returns>The first object that matches the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetFirst(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Queries for one object that matches the given criteria.
            </summary>
            <returns>The first object that matches the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Get(System.String,System.Object)">
            <summary>
            Queries for objects where the property matches the given value.
            </summary>
            <param name="propertyName">Property or Field on the object you want to match a value.</param>
            <param name="propertyValue">Value that the Property or Field should have.</param>
            <returns>All objects that match the criteria, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Get(Azavea.Open.DAO.ITransaction,System.String,System.Object)">
            <summary>
            Queries for objects where the property matches the given value.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="propertyName">Property or Field on the object you want to match a value.</param>
            <param name="propertyValue">Value that the Property or Field should have.</param>
            <returns>All objects that match the criteria, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Get(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Queries and returns objects matching the criteria.
            </summary>
            <returns>A list of objects, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Get(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Queries and returns objects matching the criteria.
            </summary>
            <returns>A list of objects, or an empty list (not null).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetCount(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Returns the number of objects matching the given criteria.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Returns the number of objects matching the given criteria.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetCount(Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression})">
            <summary>
            Returns the number of objects of the specified type matching the given criteria,
            aggregated by the given grouping expressions.  This matches "GROUP BY" behavior
            in SQL.
            </summary>
            <param name="crit">The criteria that you wish the objects to match.  Start/limit and order are ignored.</param>
            <param name="groupExpressions">The fields/expressions to aggregate on when counting.</param>
            <returns>The number of objects that match the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression})">
            <summary>
            Returns the number of objects of the specified type matching the given criteria,
            aggregated by the given grouping expressions.  This matches "GROUP BY" behavior
            in SQL.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">The criteria that you wish the objects to match.  Start/limit and order are ignored.</param>
            <param name="groupExpressions">The fields/expressions to aggregate on when counting.</param>
            <returns>The number of objects that match the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Iterate``1(Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.DaoIterationDelegate{`0,``0},``0,System.String)">
            <summary>
            Queries for objects, similar to Get, except that this iterates over the resulting
            records and invokes the specified delegate for each one.  This allows processing of much
            larger result sets since it doesn't attempt to load all the objects into memory at once.
            </summary>
            <param name="criteria">Any criteria for the query.  May be null for "all records".</param>
            <param name="invokeMe">The method to invoke for each object returned by the query.</param>
            <param name="parameters">Any parameters that you want to pass to the invokeMe method.
                                       This may be null.</param>
            <param name="desc">Description of the loop for logging purposes.</param>
            <returns>The number of objects iterated over.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Iterate``1(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.DaoIterationDelegate{`0,``0},``0,System.String)">
            <summary>
            Queries for objects, similar to Get, except that this iterates over the resulting
            records and invokes the specified delegate for each one.  This allows processing of much
            larger result sets since it doesn't attempt to load all the objects into memory at once.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="criteria">Any criteria for the query.  May be null for "all records".</param>
            <param name="invokeMe">The method to invoke for each object returned by the query.</param>
            <param name="parameters">Any parameters that you want to pass to the invokeMe method.
                                       This may be null.</param>
            <param name="desc">Description of the loop for logging purposes.</param>
            <returns>The number of objects iterated over.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Get``1(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0})">
            <summary>
            This allows joining between two DAOs.  Assuming both are using the same data
            source, and joins are implemented in the data access layer, this will use
            native joins (I.E. JOIN keyword in SQL) and be fast.  If not, this will use
            the "PseudoJoiner", and be less fast (though not horrible most of the time,
            depending on the number of records and the data sources involved).
            </summary>
            <param name="crit">An object describing how to join the two DAOs.  Includes any
                               criteria that apply to the right or left DAO.</param>
            <param name="rightDao">The other DAO we are joining against.</param>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <returns>A list of KeyValuePairs.  The Key is the object from this </returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.Get``1(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0})">
            <summary>
            This allows joining between two DAOs.  Assuming both are using the same data
            source, and joins are implemented in the data access layer, this will use
            native joins (I.E. JOIN keyword in SQL) and be fast.  If not, this will use
            the "PseudoJoiner", and be less fast (though not horrible most of the time,
            depending on the number of records and the data sources involved).
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">An object describing how to join the two DAOs.  Includes any
                               criteria that apply to the right or left DAO.</param>
            <param name="rightDao">The other DAO we are joining against.</param>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <returns>A list of KeyValuePairs.  The Key is the object from this </returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetCount``1(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0})">
            <summary>
            Performs a join using the given join criteria and returns the number of objects that
            would result from the join if you called Get.
            
            Whether this is faster than calling Get depends on the implementation.
            </summary>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <param name="crit">An object describing how to join the two DAOs.  Includes any
                               criteria that apply to the right or left DAO.</param>
            <param name="rightDao">The other DAO we are joining against.</param>
            <returns>The number of join results that matched the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetCount``1(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0})">
            <summary>
            Performs a join using the given join criteria and returns the number of objects that
            would result from the join if you called Get.
            
            Whether this is faster than calling Get depends on the implementation.
            </summary>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">An object describing how to join the two DAOs.  Includes any
                               criteria that apply to the right or left DAO.</param>
            <param name="rightDao">The other DAO we are joining against.</param>
            <returns>The number of join results that matched the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetValueFromObject(`0,System.String)">
            <summary>
            This object gets a value off the data object based on the
            name of the field/property.
            </summary>
            <param name="dataObject">The object to get a value off of.</param>
            <param name="fieldName">The name of the field/property to get the value of.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetFieldValues(`0,System.Collections.Generic.IDictionary{System.String,System.Object},Azavea.Open.DAO.ClassMapping,System.Boolean,System.Boolean)">
            <summary>
            This method takes property/field values from the data object
            and puts them into the dictionary 'putEmHere', keyed by the column names.
            </summary>
            <param name="dataObject">An implementation-specific data object.</param>
            <param name="putEmHere">A dictionary to insert values into.  Values will be objects
                                    (which may be null) keyed by column names.  The values
                                    will be cast to the appropriate type for the db, if necessary.</param>
            <param name="classMap">The class map for the object.</param>
            <param name="idFields">If true, we copy the ID fields.</param>
            <param name="dataFields">If true, we copy the non-ID fields.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.PopulateIDCriteria(`0,Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Populates a criteria with a bunch of EqualExpressions, one for each
            ID on the data object.
            </summary>
            <param name="dataObject">The object we're concerned with.</param>
            <param name="crit">Criteria to add equals expressions to.</param>
            <param name="classMap">The mapping of the object to the data source.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.IsIDValid(`0)">
            <summary>
            Returns true if the objects id field(s) have non-null values that, if numeric, are greater
            than zero.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.ProcessIdColumnsForInsert(`0,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Updates the column list of the object we plan to insert, based on the id generator type 
            in the mpaping file.
            </summary>
            <param name="dataObj">The object bring inserted.</param>
            <param name="idCols">The list of id columns</param>
            <param name="cols">The current list of columns to write</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.SaveRecord(Azavea.Open.DAO.ITransaction,`0,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Updates the appropriate record, or inserts a new record if there is no
            record with the primary key values of this object, based on the allow flags.
            Note that using this with allowUpdate and allowInsert both true can be inefficient,
            because if the record is new it will first attempt an update which will fail.
            However sometimes it is inconvenient to determine first whether the record exists,
            which is why this method exists.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="dataObject">An implementation-specific data object.  For example, if the
                                       implementation class is "Topic", dataObject would be expected
                                       to be type "TopicRecord".  An ArgumentException will be thrown
                                       if it is not the correct type.</param>
            <param name="allowUpdate">If this is true, an existing record will be updated if one
                                      exists.  If allowInsert is false, only an update will be
                                      attempted.</param>
            <param name="allowInsert">If this is true, a new record will be inserted if there is not
                                      one already present to update.  If allowUpdate is false, only
                                      an insert will be attempted.</param>
            <param name="setGeneratedId">If this is true, if the action is an insert, then the object
                                         that is inserted will have ID fields that were generated by
                                         the database filled in.  This is supported differently on
                                         different databases.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.PostInsert(Azavea.Open.DAO.ITransaction,`0)">
            <summary>
            Called after an insert, may be overridden to do anything necessary after inserting
            this object type.  An example (the default behavior) is to set the auto-generated
            ID values back on the object that was saved.
            
            NOTE: This appears to only be called if setGeneratedId is true, which means NOT
                  after every insert!
            </summary>
            <param name="currentTransaction">The current transaction (if there is one) that we're
                                             executing as part of.</param>
            <param name="insertee">Object that was just inserted into the DB.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.PopulateColNums(System.Data.IDataReader,System.Collections.Generic.IDictionary{System.String,System.Int32},System.String)">
            <summary>
            Populates the dictionary of column name to index mappings, so that
            we can minimize the number of times we call GetOrdinal.
            </summary>
            <param name="reader">Reader that has been generated from some query.</param>
            <param name="colNums">Mapping dictionary to populate.</param>
            <param name="colNamePrefix">The prefix (if any) to use for looking up our
                                        columns from the data reader.  I.E. "TableName." or
                                        "TableAlias." or whatever.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.SetValueOnObject(`0,Azavea.Open.DAO.ClassMapping,System.String,System.Object)">
            <summary>
            Given an object and a (data source) column name
            set the given memberValue onto the object's property.
            </summary>
            <param name="dataObj">Object to set the value upon.</param>
            <param name="classMap">Object's mapping.</param>
            <param name="colName">Name of the column we got the value from.</param>
            <param name="memberValue">Value to set on the field or property.</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.SetValueOnObjectProperty(`0,System.Object,System.Reflection.MemberInfo)">
            <summary>
            Given an object and a MemberInfo object
            set the given memberValue onto the object's property.
            </summary>
            <param name="dataObj">Object to set the value upon.</param>
            <param name="memberValue">The new value to set</param>
            <param name="info">The metadata pertaining to the object property (taken from the ClassMapping)</param>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.GetDataObjectFromReader(System.Data.IDataReader,System.Collections.Generic.IDictionary{System.String,System.Int32},System.String)">
            <summary>
            This method returns an object that has been loaded from the current
            row of the data reader.
            </summary>
            <param name="reader">The reader, which should already be positioned on the row to read.</param>
            <param name="colNums">A dictionary of column name to index mappings (faster than calling
                                  GetOrdinal over and over again).</param>
            <param name="colPrefix">The prefix (if any) to use when looking for columns by name.</param>
            <returns>The newly loaded data object.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.CreateObjectsFromReader(System.Collections.Hashtable,System.Data.IDataReader)">
            <summary>
            Reads all records from the reader, creating objects and inserting them into
            the parameters hashtable as a collection called "items".  An exception on
            any one record will cause this method to fail.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.IterateOverObjectsFromReader``1(System.Collections.Hashtable,System.Data.IDataReader)">
            <summary>
            Reads records one at a time from the reader, creating objects and calling
            the 'invokeMe' delegate for each one.  An exception while processing any
            one object will cause this method to fail.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.IterateOverQuery``1(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.IDaQuery,Azavea.Open.DAO.DaoIterationDelegate{`0,``0},``0,System.Int32,System.String)">
            <summary>
            Helper that does the work once the query is created.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="query">The query to execute that is expected to return a large
                                 number of rows.</param>
            <param name="invokeMe">The method to invoke for each object returned by the query.</param>
            <param name="parameters">Any parameters that you want to pass to the invokeMe method.
                                       This may be null.</param>
            <param name="max">maximum number of records to iterate over, int.MaxValue will mean no limit.</param>
            <param name="desc">Description of the loop for logging purposes.</param>
            <returns>the number of records iterated over.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.FastDAO`1.ToString">
            <summary>
            ToString implementation.
            </summary>
            <returns>The type name and what table it is mapped to.</returns>
        </member>
        <member name="P:Azavea.Open.DAO.FastDAO`1.Table">
            <summary>
            The name of the table (or equivalent) in the data storage that this DAO reads/writes to/from.
            </summary>
        </member>
        <member name="P:Azavea.Open.DAO.FastDAO`1.ClassMap">
            <summary>
            The class mapping used to map this DAO's data object type to the data storage.
            </summary>
        </member>
        <member name="P:Azavea.Open.DAO.FastDAO`1.ConnDesc">
            <summary>
            The object describing how to connect to and/or interact with the data
            source we're reading objects from.
            </summary>
        </member>
        <member name="P:Azavea.Open.DAO.FastDAO`1.DataAccessLayer">
            <summary>
            The lower-level object with more direct database access.  You should only
            ever use this if you're trying to do something complicated that the FastDAO
            interface doesn't expose.
            
            NOTE: Using this directly can be less efficient if you are not careful.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.#ctor(System.String,System.String,System.String)">
            <summary>
            This allows you to specify the config name and the section in the config file
            used to get the database config info.
            </summary>
            <param name="mappedType">The type name we're mapping.  Since this class doesn't
                                     actually instantiate it, it can just be the key to the
                                     config file and doesn't have to be a real class.</param>
            <param name="configName">Name used to get the configuration.</param>
            <param name="sectionName">Name of the section within the config file.</param>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.#ctor(System.String,System.String,System.String,Azavea.Open.DAO.ConnectionInfoDecryptionDelegate)">
            <summary>
            This allows you to specify the config name and the section in the config file
            used to get the database config info.
            </summary>
            <param name="mappedType">The type name we're mapping.  Since this class doesn't
                                     actually instantiate it, it can just be the key to the
                                     config file and doesn't have to be a real class.</param>
            <param name="configName">Name used to get the configuration.</param>
            <param name="sectionName">Name of the section within the config file.</param>
            <param name="decryptionDelegate">The method to call to decrypt passwords or
                                             other encrypted connection info.  May be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.#ctor(System.String,Azavea.Open.Common.Config,System.String)">
            <summary>
            This allows you to give the config object and the section in the config
            used to get the database config info.
            </summary>
            <param name="mappedType">The type name we're mapping.  Since this class doesn't
                                     actually instantiate it, it can just be the key to the
                                     config file and doesn't have to be a real class.</param>
            <param name="config">Configuration object loaded somewhere else.</param>
            <param name="sectionName">Name of the section within the config.</param>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.#ctor(System.String,Azavea.Open.Common.Config,System.String,Azavea.Open.DAO.ConnectionInfoDecryptionDelegate)">
            <summary>
            This allows you to give the config object and the section in the config
            used to get the database config info.
            </summary>
            <param name="mappedType">The type name we're mapping.  Since this class doesn't
                                     actually instantiate it, it can just be the key to the
                                     config file and doesn't have to be a real class.</param>
            <param name="config">Configuration object loaded somewhere else.</param>
            <param name="sectionName">Name of the section within the config.</param>
            <param name="decryptionDelegate">The method to call to decrypt passwords or
                                             other encrypted connection info.  May be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.#ctor(System.String,Azavea.Open.DAO.IConnectionDescriptor,System.String)">
            <summary>
            This allows you to specify the data source connection and the mapping file.
            </summary>
            <param name="mappedType">The type name we're mapping.  Since this class doesn't
                                     actually instantiate it, it can just be the key to the
                                     config file and doesn't have to be a real class.</param>
            <param name="connDesc">Data source Connection information.</param>
            <param name="mappingFileName">Filename (with path) to the mapping file.</param>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.#ctor(Azavea.Open.DAO.IConnectionDescriptor,Azavea.Open.DAO.ClassMapping)">
            <summary>
            If you already have the data source connection and the mapping file, you may use
            this constructor.
            </summary>
            <param name="connDesc">Data source Connection information.</param>
            <param name="mapping">ClassMapping describing the class to be mapped and
                                  the table to map it to.</param>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.ParseHibernateConfig(System.String,System.String)">
            <summary>
            This version of this method looks for a matching string, not a matching type.
            TODO: Refactor FastDAO to look for the object type name rather than trying to
                  parse the type out of the mapping file.  Then we don't need the other
                  version, and this can be moved to FastDAO and made protected.
            </summary>
            <param name="desiredType">The type we're loading a mapping for.</param>
            <param name="fileName">XML File containing an NHibernate configuration.</param>
            <returns>The class mapping for the desired type.  If unable to find it, an
                     exception is thrown, so you may safely assume this will never return
                     null.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.GetFieldValues(Azavea.Open.Common.Collections.CheckedDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object},Azavea.Open.DAO.ClassMapping,System.Boolean,System.Boolean)">
            <summary>
            This method takes property/field values from the data object
            and puts them into the dictionary 'putEmHere', keyed by the column names.
            </summary>
            <param name="dataObject">An implementation-specific data object.</param>
            <param name="putEmHere">A dictionary to insert values into.  Values will be objects
                                    (which may be null) keyed by column names.  The values
                                    will be cast to the appropriate type for the db, if necessary.</param>
            <param name="classMap">The class map for the object.</param>
            <param name="idFields">If true, we copy the ID fields.</param>
            <param name="dataFields">If true, we copy the non-ID fields.</param>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.GetValueFromObject(Azavea.Open.Common.Collections.CheckedDictionary{System.String,System.Object},System.String)">
            <summary>
            This object gets a value off the data object based on the
            name of the field/property.
            </summary>
            <param name="dataObject">The object to get a value off of.</param>
            <param name="fieldName">The name of the field/property to get the value of.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.SetValueOnObject(Azavea.Open.Common.Collections.CheckedDictionary{System.String,System.Object},Azavea.Open.DAO.ClassMapping,System.String,System.Object)">
            <summary>
            Given an object and a (data source) column name
            set the given memberValue onto the object's property.
            
            Since the DictionaryDAO is probably used only for reading,
            it will tolerate the same column mapped to more than one property
            (normal FastDAO will not work if you try that).
            </summary>
            <param name="dataObj">Object to set the value upon.</param>
            <param name="classMap">Object's mapping.</param>
            <param name="colName">Name of the column we got the value from.</param>
            <param name="memberValue">Value to set on the field or property.</param>
        </member>
        <member name="M:Azavea.Open.DAO.DictionaryDao.PopulateIDCriteria(Azavea.Open.Common.Collections.CheckedDictionary{System.String,System.Object},Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Populates a criteria with a bunch of EqualExpressions, one for each
            ID on the data object.
            </summary>
            <param name="dataObject">The object we're concerned with.</param>
            <param name="crit">Criteria to add equals expressions to.</param>
            <param name="classMap">The mapping of the object to the data source.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.AlreadyTerminatedException">
            <summary>
            This exception is thrown when trying to close or finish something that
            has already been closed or finished (I.E. committing a transaction more than once).
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.AlreadyTerminatedException.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.String)">
            <summary>
            This has already been closed/terminated/etc.
            </summary>
            <param name="desc">Connection descriptor we were using.</param>
            <param name="message">What was already terminated.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.UnableToCreateTransactionException">
            <summary>
            This exception is thrown when we are unable to begin a transaction.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.UnableToCreateTransactionException.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.Exception)">
            <summary>
            Unable to begin a transaction against the database.
            </summary>
            <param name="desc">Connection descriptor we were using to try to connect.</param>
            <param name="e">Exception that was thrown by the database driver.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.UnexpectedResultsException">
            <summary>
            This exception is thrown when we got something back that was incorrect,
            such as wrong data fields, or wrong number of results, etc.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.UnexpectedResultsException.#ctor(System.String,Azavea.Open.DAO.IConnectionDescriptor)">
            <summary>
            Results from an operation were not correct.
            </summary>
            <param name="message">Start of the message, if you don't want to use the default.</param>
            <param name="desc">Connection descriptor we connected with.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.UnexpectedResultsException.#ctor(System.String,Azavea.Open.DAO.IConnectionDescriptor,System.Exception)">
            <summary>
            Results from an operation were not correct.
            </summary>
            <param name="message">Start of the message, if you don't want to use the default.</param>
            <param name="desc">Connection descriptor we connected with.</param>
            <param name="e">Exception that was thrown by the delegate.</param>
        </member>
        <member name="T:Azavea.Open.DAO.DaJoinDelegate">
            <summary>
            This describes a method to be executed by the ExecuteJoin call.  This delegate
            will be called once and passed the IDataReader that was the result of the join query.  It is
            up to the delegate to iterate through the results if it wants to.
            </summary>
            <param name="parameters">A hashtable containing anything at all.  This is used as
                                     a way of passing parameters to the delegate, or as a way
                                     for the delegate to return values to the function that called
                                     it through the ExecuteJoin method.
                                     This parameter may be null.</param>
            <param name="leftColumnPrefix">The prefix to use when querying the IDataReader for the
                                           columns of the left table by name.  Either leftColumnPrefix or
                                           rightColumnPrefix can be null, but both cannot be null due
                                           to the possibility of duplicate columns (if both tables have an
                                           "ID" column for example).  This may be the table name, or a
                                           made up string like "left" or "table1".</param>
            <param name="rightColumnPrefix">The prefix to use when querying the IDataReader for the
                                           columns of the right table by name.  Either leftColumnPrefix or
                                           rightColumnPrefix can be null, but both cannot be null due
                                           to the possibility of duplicate columns (if both tables have an
                                           "ID" column for example).  This may be the table name, or a
                                           made up string like "right" or "table1".</param>
            <param name="reader">The data reader with the results of the database query.</param>
        </member>
        <member name="T:Azavea.Open.DAO.DaoIterationDelegate`2">
            <summary>
            This describes a method to be executed by the QueryAndIterateOverObjects call.  This delegate
            will be called once per record returned by the query and passed the data object that was
            created for that record.
            </summary>
            <typeparam name="T">The type of the data objects being processed.</typeparam>
            <typeparam name="P">The type of the 'parameters' object the delegate accepts.  A common
                                pattern is to make this a Hashtable, thus allowing a collecion of
                                values to be passed in, and allowing values to be returned.</typeparam>
            <param name="parameters">A dictionary containing anything at all.  This is used as
                                     a way of passing parameters to the delegate, or as a way
                                     for the delegate to return values to the function that called
                                     it through the Iterate method.
                                     This parameter may be null.</param>
            <param name="dataObject">A single data object retrieved from a query.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.BadConnectionTypeException">
            <summary>
            This exception is thrown when the connection you have is wrong for what
            you're trying to do.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.BadConnectionTypeException.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.String)">
            <summary>
            This connection can't do that.
            </summary>
            <param name="desc">Connection descriptor we were using to try to connect.</param>
            <param name="message">A message describing what is wrong with the connection type.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.UnableToConstructSqlException">
            <summary>
            This exception is thrown when we are unable to construct a SQL statement,
            possibly due to bad values, expression types that are not supported, etc.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.UnableToConstructSqlException.#ctor(System.String,Azavea.Open.DAO.IConnectionDescriptor,System.Exception)">
            <summary>
            Unable to construct a SQL statement.
            </summary>
            <param name="message">Start of the message, if you don't want to use the default.</param>
            <param name="desc">Connection descriptor we would have connected with.</param>
            <param name="e">Exception that was thrown by the database driver.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.DaoTypeCoercionException">
            <summary>
            This is the type of exception thrown by CoerceType.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Exceptions.DaoTypeCoercionException.DesiredType">
            <summary>
            Type we were trying to coerce the value to.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Exceptions.DaoTypeCoercionException.Value">
            <summary>
            The value that was trying to be coerced.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.DaoTypeCoercionException.#ctor(System.Type,System.Object,System.Exception)">
            <summary>
            Creates a coercion exception.
            </summary>
            <param name="desiredType">Type we were trying to coerce the value to.</param>
            <param name="value">The value that was trying to be coerced.</param>
            <param name="innerException">Exception that was thrown (if any, may be null).</param>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.DaoTypeCoercionException.#ctor(System.Type,System.Object,System.String,System.Exception)">
            <summary>
            Creates a coercion exception.
            </summary>
            <param name="desiredType">Type we were trying to coerce the value to.</param>
            <param name="value">The value that was trying to be coerced.</param>
            <param name="reason">Why it did not work.</param>
            <param name="innerException">Exception that was thrown (if any, may be null).</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.DaoUnsupportedTypeCoercionException">
            <summary>
            This is a specialized subtype of the coerce exception, thrown when you attempt to convert
            a value to an unsupported type.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.DaoUnsupportedTypeCoercionException.#ctor(System.Type,System.Object)">
            <summary>
            Creates a coercion exception for when the type being coerced to is
            not supported.
            </summary>
            <param name="desiredType">Type we were trying to coerce the value to.</param>
            <param name="value">The value that was trying to be coerced.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.UnableToConnectException">
            <summary>
            This exception is thrown when we are unable to connect to a database.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.UnableToConnectException.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.Int32,System.Exception)">
            <summary>
            Unable to establish a database connection.
            </summary>
            <param name="desc">Connection descriptor we were using to try to connect.</param>
            <param name="numTimes">How many times in a row have we failed to connect, if
                                   known.  This is used in the message only if it is greater
                                   than 1.</param>
            <param name="e">Exception that was thrown by the database driver.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.UnableToProcessSqlResultsException">
            <summary>
            This exception is thrown when something went wrong while dealing with
            what we got back from the database query, not with the database query itself.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.UnableToProcessSqlResultsException.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.String,System.Collections.IEnumerable,System.Exception)">
            <summary>
            Error while processing SQL results.
            </summary>
            <param name="desc">Connection descriptor we connected with.</param>
            <param name="sql">SQL statement we were executed.</param>
            <param name="sqlParams">Parameters for the sql statement (may be null).</param>
            <param name="e">Exception that was thrown by the delegate.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.UnableToProcessSqlResultsException.#ctor(System.String,Azavea.Open.DAO.IConnectionDescriptor,System.String,System.Collections.IEnumerable,System.Exception)">
            <summary>
            Error while processing SQL results.
            </summary>
            <param name="message">Start of the message, if you don't want to use the default.</param>
            <param name="desc">Connection descriptor we connected with.</param>
            <param name="sql">SQL statement we executed.</param>
            <param name="sqlParams">Parameters for the sql statement (may be null).</param>
            <param name="e">Exception that was thrown by the delegate.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.UnableToRunSqlException">
            <summary>
            This exception is thrown when we are able to connect to a DB, but we get an
            exception executing a SQL statement.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.UnableToRunSqlException.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.String,System.Collections.IEnumerable,System.Exception)">
            <summary>
            Unable to execute SQL.
            </summary>
            <param name="desc">Connection descriptor we connected with.</param>
            <param name="sql">SQL statement we were trying to execute.</param>
            <param name="sqlParams">Parameters for the sql statement (may be null).</param>
            <param name="e">Exception that was thrown by the database driver.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.UnableToRunSqlException.#ctor(System.String,Azavea.Open.DAO.IConnectionDescriptor,System.String,System.Collections.IEnumerable,System.Exception)">
            <summary>
            Unable to execute SQL.
            </summary>
            <param name="message">Start of the message, if you don't want to use the default.</param>
            <param name="desc">Connection descriptor we connected with.</param>
            <param name="sql">SQL statement we were trying to execute.</param>
            <param name="sqlParams">Parameters for the sql statement (may be null).</param>
            <param name="e">Exception that was thrown by the database driver.</param>
        </member>
        <member name="T:Azavea.Open.DAO.AbstractDaLayer">
            <summary>
            Defines an interface that FastDAO can use to run data access functions that 
            are specific to a particular data source (e.g. sql-based database).
            
            This class, and all classes that extend it, should be thread-safe.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.IDaLayer">
            <summary>
            Defines an interface that FastDAO can use to run data access functions that 
            are specific to a particular data source (e.g. sql-based database).
            
            This class, and all classes that extend it, should be thread-safe.
            
            NOTE on transactions: The methods on the interface accept transactions,
            but if your data source does not support transactions (or you have not
            yet implemented support), you may ignore that parameter as long as your
            equivilent IConnectionDescriptor is not an ITransactionalConnectionDescriptor.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.SupportsNumRecords">
            <summary>
            If true, methods that return numbers of records affected will be
            returning accurate numbers.  If false, they will return
            UNKNOWN_NUM_ROWS.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.AddCoercibleType(System.Type,Azavea.Open.DAO.TypeCoercionDelegate)">
            <summary>
            A method to add a coercion delegate for a type, without exposing the dictionary.
            </summary>
            <param name="t">The type to coerce.</param>
            <param name="coercionDelegate">How to coerce it.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.Delete(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Deletes a data object record using the mapping and criteria for what's deleted.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="mapping">The mapping of the table from which to delete.</param>
            <param name="crit">Criteria for deletion.  NOTE: Only the expressions are observed,
                               other things (like "order" or start / limit) are ignored.
                               WARNING: A null or empty (no expression) criteria will 
                               delete ALL records!</param>
            <returns>The number of records affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.Truncate(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Deletes all contents of the table.  Faster for large tables than DeleteAll,
            but requires greater permissions.  For layers that do not support this, the
            behavior should be the same as calling Delete(null, mapping).
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.Insert(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Inserts a data object record using the "table" and a list of column/value pairs.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="propValues">A dictionary of "column"/value pairs for the object to insert.</param>
            <returns>The number of records affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.InsertBatch(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.List{System.Collections.Generic.IDictionary{System.String,System.Object}})">
            <summary>
            Inserts a list of data object records of the same type.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="propValueDictionaries">A list of dictionaries of column/value pairs.  
                                                Each item in the list should represent the dictionary of column/value pairs for 
                                                each respective object being inserted.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.Update(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Updates a data object record using the "table" and a list of column/value pairs.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="crit">All records matching this criteria will be updated per the dictionary of
                               values.</param>
            <param name="propValues">A dictionary of column/value pairs for all non-ID columns to be updated.</param>
            <returns>The number of records affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.UpdateBatch(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.List{Azavea.Open.DAO.Criteria.DaoCriteria},System.Collections.Generic.List{System.Collections.Generic.IDictionary{System.String,System.Object}})">
            <summary>
            Updates a list of data object records of the same type.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="criteriaList">A list of DaoCriteria.
                                       Each item in the list should represent the criteria for 
                                       rows that will be updated per the accompanying dictionary.</param>
            <param name="propValueDictionaries">A list of dictionaries of column/value pairs.
                                              Each item in the list should represent the dictionary of non-ID column/value pairs for 
                                              each respective object being updated.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.CreateQuery(Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Builds the query based on a serializable criteria.  The Query object is particular to
            the implementation, but may contain things like the parameters parsed out, or whatever
            makes sense to this FastDaoLayer.  You can think of this method as a method to convert
            from the generic DaoCriteria into the specific details necessary for querying.
            </summary>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <param name="crit">The criteria to use to find the desired objects.</param>
            <returns>A query that can be run by ExecureQuery.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.ExecuteQuery(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.IDaQuery,Azavea.Open.DAO.Util.DataReaderDelegate,System.Collections.Hashtable)">
            <summary>
            Executes a query and invokes a method with a DataReader of results.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="mapping">Class mapping for the table we're querying against.  Optional,
                                  but not all columns may be properly typed if it is null.</param>
            <param name="query">The query to execute, should have come from CreateQuery.</param>
            <param name="invokeMe">The method to invoke with the IDataReader results.</param>
            <param name="parameters">A hashtable containing any values that need to be persisted through invoked method.
                                     The list of objects from the query will be placed here.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.DisposeOfQuery(Azavea.Open.DAO.IDaQuery)">
            <summary>
            Should be called when you're done with the query.  Allows us to cache the
            objects for reuse.
            </summary>
            <param name="query">Query you're done using.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Gets a count of records for the given criteria.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <param name="crit">The criteria to use for "where" comparisons.</param>
            <returns>The number of results found that matched the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression})">
            <summary>
            Gets a count of records for the given criteria,
            aggregated by the given grouping expressions.  This matches "GROUP BY" behavior
            in SQL.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <param name="crit">The criteria to use for "where" comparisons.</param>
            <param name="groupExpressions">The fields/expressions to aggregate on when counting.</param>
            <returns>The number of objects that match the criteria, plus the values of those objects
                     for the fields that were aggregated on.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.CoerceType(System.Type,System.Object)">
            <summary>
            Attempts to convert the value into the given type.  While broadly
            similar to Convert.ChangeType, that method doesn't support enums and this one does.
            Calling that from within this method makes it take nearly twice as long, so this method
            does its own type checking.
            </summary>
            <param name="desiredType">Type we need the value to be.</param>
            <param name="input">Input value, may or may not already be the right type.</param>
            <returns>An object of type desiredType whose value is equal to the input.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.GetLastAutoGeneratedId(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.String)">
            <summary>
            Finds the last generated id number for a column.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="mapping">The class mapping for the table being queried.</param>
            <param name="idCol">The ID column for which to find the last-generated ID.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaLayer.GetNextSequenceValue(Azavea.Open.DAO.ITransaction,System.String)">
            <summary>
            Gets the next id number from a sequence in the data source.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="sequenceName">The name of the sequence.</param>
            <returns>The next number from the sequence.</returns>
        </member>
        <member name="F:Azavea.Open.DAO.AbstractDaLayer._log">
            <summary>
            log4net logger that any child class may use for logging any appropriate messages.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.AbstractDaLayer._connDesc">
            <summary>
            The connection descriptor that is being used by this FastDaoLayer.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.SupportsNumRecords">
            <summary>
            If true, methods that return numbers of records affected will be
            returning accurate numbers.  If false, they will return
            UNKNOWN_NUM_ROWS.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.AbstractDaLayer._coerceableTypes">
            <summary>
            A mapping of additional types that can be handled by this DAO to methods for handling them.  
            It is initially null, but can be created and aded to by a subclass to easily allow for
            handling arbitrary data types.
            
            Use must be synchronized!
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.Boolean)">
            <summary>
            Instantiates the data access layer with the connection descriptor for the DB.
            </summary>
            <param name="connDesc">The connection descriptor that is being used by this FastDaoLayer.</param>
            <param name="supportsNumRecords">If true, methods that return numbers of records affected will be
                                            returning accurate numbers.  If false, they will probably return
                                            FastDAO.UNKNOWN_NUM_ROWS.</param>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.AddCoercibleType(System.Type,Azavea.Open.DAO.TypeCoercionDelegate)">
            <summary>
            A method to add a coercion delegate for a type, without exposing the dictionary.
            </summary>
            <param name="t">The type to coerce.</param>
            <param name="coercionDelegate">How to coerce it.</param>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.Delete(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Deletes a data object record using the mapping and criteria for what's deleted.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table from which to delete.</param>
            <param name="crit">Criteria for deletion.  NOTE: Only the expressions are observed,
                               other things (like "order" or start / limit) are ignored.
                               WARNING: A null or empty (no expression) criteria will 
                               delete ALL records!</param>
            <returns>The number of records affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.Truncate(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Deletes all contents of the table.  Faster for large tables than DeleteAll,
            but requires greater permissions.  For layers that do not support this, the
            behavior should be the same as calling Delete(null, mapping).
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.Insert(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Inserts a data object record using the "table" and a list of column/value pairs.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="propValues">A dictionary of "column"/value pairs for the object to insert.</param>
            <returns>The number of records affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.InsertBatch(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.List{System.Collections.Generic.IDictionary{System.String,System.Object}})">
            <summary>
            Inserts a list of data object records of the same type.  The default implementation
            merely calls Insert for each one, however some datasources may have more efficient
            ways of inserting multiple records that the appropriate DaLayer will take advantage of.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="propValueDictionaries">A list of dictionaries of column/value pairs.  
                                                Each item in the list should represent the dictionary of column/value pairs for 
                                                each respective object being inserted.</param>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.Update(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Updates a data object record using the "table" and a list of column/value pairs.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="crit">All records matching this criteria will be updated per the dictionary of
                               values.</param>
            <param name="propValues">A dictionary of column/value pairs for all non-ID columns to be updated.</param>
            <returns>The number of records affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.UpdateBatch(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.List{Azavea.Open.DAO.Criteria.DaoCriteria},System.Collections.Generic.List{System.Collections.Generic.IDictionary{System.String,System.Object}})">
            <summary>
            Updates a list of data object records of the same type.  The default implementation
            merely calls Update for each one, however some datasources may have more efficient
            ways of inserting multiple records that the appropriate DaLayer will take advantage of.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="criteriaList">A list of DaoCriteria.
                                       Each item in the list should represent the criteria for 
                                       rows that will be updated per the accompanying dictionary.</param>
            <param name="propValueDictionaries">A list of dictionaries of column/value pairs.
                                              Each item in the list should represent the dictionary of non-ID column/value pairs for 
                                              each respective object being updated.</param>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.CreateQuery(Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Builds the query based on a serializable criteria.  The Query object is particular to
            the implementation, but may contain things like the parameters parsed out, or whatever
            makes sense to this FastDaoLayer.  You can think of this method as a method to convert
            from the generic DaoCriteria into the specific details necessary for querying.
            </summary>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <param name="crit">The criteria to use to find the desired objects.</param>
            <returns>A query that can be run by ExecureQuery.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.ExecuteQuery(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.IDaQuery,Azavea.Open.DAO.Util.DataReaderDelegate,System.Collections.Hashtable)">
            <summary>
            Executes a query and invokes a method with a DataReader of results.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">Class mapping for the table we're querying against.  Optional,
                                  but not all columns may be properly typed if it is null.</param>
            <param name="query">The query to execute, should have come from CreateQuery.</param>
            <param name="invokeMe">The method to invoke with the IDataReader results.</param>
            <param name="parameters">A hashtable containing any values that need to be persisted through invoked method.
                                     The list of objects from the query will be placed here.</param>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.DisposeOfQuery(Azavea.Open.DAO.IDaQuery)">
            <summary>
            Should be called when you're done with the query.  Allows us to cache the
            objects for reuse.
            </summary>
            <param name="query">Query you're done using.</param>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Gets a count of records for the given criteria.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <param name="crit">The criteria to use for "where" comparisons.</param>
            <returns>The number of results found that matched the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression})">
            <summary>
            Gets a count of records for the given criteria,
            aggregated by the given grouping expressions.  This matches "GROUP BY" behavior
            in SQL.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <param name="crit">The criteria to use for "where" comparisons.</param>
            <param name="groupExpressions">The fields/expressions to aggregate on when counting.</param>
            <returns>The number of objects that match the criteria, plus the values of those objects
                     for the fields that were aggregated on.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.CoerceType(System.Type,System.Object)">
            <summary>
            Attempts to convert the value into the given type.  While broadly
            similar to Convert.ChangeType, that method doesn't support enums and this one does.
            Calling that from within this method makes it take nearly twice as long, so this method
            does its own type checking.
            </summary>
            <param name="desiredType">Type we need the value to be.</param>
            <param name="input">Input value, may or may not already be the right type.</param>
            <returns>An object of type desiredType whose value is equal to the input.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.GetDataType(System.String,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Given the class mapping and the column name, determines the appropriate
            c# data type.
            </summary>
            <param name="col">Column to look up.</param>
            <param name="mapping">Mapping for the class we're creating a table for.</param>
            <returns>A C# type that will be stored in the column.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.GetLastAutoGeneratedId(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.String)">
            <summary>
            Finds the last generated id number for a column.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The class mapping for the table being queried.</param>
            <param name="idCol">The ID column for which to find the last-generated ID.</param>
        </member>
        <member name="M:Azavea.Open.DAO.AbstractDaLayer.GetNextSequenceValue(Azavea.Open.DAO.ITransaction,System.String)">
            <summary>
            Gets the next id number from a sequence in the data source.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sequenceName">The name of the sequence.</param>
            <returns>The next number from the sequence.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.GeneratorType">
            <summary>
            Indicates how IDs are generated for objects.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.GeneratorType.NONE">
            <summary>
            There is no automatic ID generation, ID fields must be set correctly
            before the object is saved.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.GeneratorType.AUTO">
            <summary>
            The database does it for us, via triggers, autonumbers, etc.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.GeneratorType.SEQUENCE">
            <summary>
            The DAO class needs to access a sequence in the DB to get the next
            available ID (currently supported only on Oracle).
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.TypeCoercionDelegate">
            <summary>
            Delegate for type coercion methods.
            </summary>
            <param name="input">The input value coming out of the reader.</param>
            <returns>The input value coerced into an object of the type required.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.AbstractExpression">
            <summary>
            This base class just provides the TrueOrNot implementation.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.IExpression">
            <summary>
            This represents a single expression, I.E. "Field = 5".  This contains the
            data class field/property name(s) and any necessary parameters.
            The type of expression indicates the relationship between the fields and/or values
            being compared by the expression.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.IExpression.TrueOrNot">
            <summary>
            This tells you whether you want things that match, or things that
            don't match, this expression.
            </summary>
            <returns>True means look for matches (I.E. ==), false means look for non-matches (I.E. !=)</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.IExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.AbstractExpression._trueOrNot">
            <summary>
            Holds the value indicating whether this expression is negated.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.AbstractExpression.#ctor(System.Boolean)">
            <summary>
            This lets you specify whether to negate this expression.
            </summary>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.AbstractExpression.TrueOrNot">
            <summary>
            This tells you whether you want things that match, or things that
            don't match, this expression.
            </summary>
            <returns>True means look for matches (I.E. ==), false means look for non-matches (I.E. !=)</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.AbstractExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.AbstractExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.AbstractSinglePropertyExpression">
            <summary>
            Base class for expressions that only check one property.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.AbstractSinglePropertyExpression.Property">
            <summary>
            The data class' property/field being compared.
            May not be null.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.AbstractSinglePropertyExpression.#ctor(System.String,System.Boolean)">
            <summary>
            Base class for expressions that only check one property.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.AbstractSinglePropertyExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.AbstractSingleValueExpression">
            <summary>
            Base class for expressions that compare one property with one value.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.AbstractSingleValueExpression.Value">
            <summary>
            The value to compare with.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.AbstractSingleValueExpression.#ctor(System.String,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Base class for expressions that only check one property.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May be null only if nullOk is true.</param>
            <param name="nullOk">Whether the value can be null or not.</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.AbstractSingleValueExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.BetweenExpression">
            <summary>
            Min &lt;= Property &lt;= Max
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.BetweenExpression.Min">
            <summary>
            The minimum acceptable value.
            May not be null.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.BetweenExpression.Max">
            <summary>
            The maximum acceptable value.
            May not be null.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.BetweenExpression.#ctor(System.String,System.Object,System.Object)">
            <summary>
            PropertyValue &lt;= Property &lt;= PropertyValue2
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="min">The minimum acceptable value. May not be null.</param>
            <param name="max">The maximum acceptable value. May not be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.BetweenExpression.#ctor(System.String,System.Object,System.Object,System.Boolean)">
            <summary>
            PropertyValue &lt;= Property &lt;= PropertyValue2
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="min">The minimum acceptable value. May not be null.</param>
            <param name="max">The maximum acceptable value. May not be null.</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.BetweenExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.BetweenExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.BitwiseAndExpression">
            <summary>
            Property AND Value equals Value
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.BitwiseAndExpression.#ctor(System.String,System.Object)">
            <summary>
            Property AND Value equals Value
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.BitwiseAndExpression.#ctor(System.String,System.Object,System.Boolean)">
            <summary>
            Property AND Value equals Value
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.BitwiseAndExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.BooleanOperator">
            <summary>
            Indicates whether the given criteria is an AND or and OR.
            For example:
            Height &gt; 5 OR Width &gt; 5 =
            "Height [MatchType.Greater] 5 [BooleanType.Or]" and
            "Width [Matchtype.Greater] 5 [BooleanType.Or]"
            
            Height &gt; 5 AND Width &gt; 5 =
            "Height [MatchType.Greater] 5 [BooleanType.AND]" and
            "Width [Matchtype.Greater] 5 [BooleanType.AND]"
            
            To represent complicated criteria groups such as 
            "Height &gt; 5 AND (Weight &gt; 5 OR Weight == 0)", you need to use
            the CriteriaExpression to nest the OR expression inside another,
            AND criteria:
            DaoCriteria(heightExp AND DaoCriteria(weightExp1 OR weightExp2)).
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.BooleanOperator.And">
            <summary>
            Indicates both are required.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.BooleanOperator.Or">
            <summary>
            Indicates either one or the other is required.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.CriteriaExpression">
            <summary>
            Used when nesting another DaoCriteria.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.CriteriaExpression.NestedCriteria">
            <summary>
            Another whole criteria to be a nested expression.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.CriteriaExpression.#ctor(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Used when nesting another criteria.
            </summary>
            <param name="crit">Another whole criteria to be a nested expression.
                               May not be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.CriteriaExpression.#ctor(Azavea.Open.DAO.Criteria.DaoCriteria,System.Boolean)">
            <summary>
            Used when nesting another criteria.
            </summary>
            <param name="crit">Another whole criteria to be a nested expression.
                               May not be null.</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.CriteriaExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Joins.JoinSortOrder">
            <summary>
            This is similar to a DaoCriteria's SortOrder, except it is necessary
            to specify which DAO, the left or the right, has this field we're sorting on.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.JoinSortOrder.IsForLeftDao">
            <summary>
            If true, the property we're sorting on comes from the left
            DAO.  If false, it comes from the right DAO.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.JoinSortOrder.#ctor(System.String,System.Boolean)">
            <summary>
            A simple class that holds a sort criterion for a property from the right or left DAO.
            This constructor creates an "ascending" sort order.
            </summary>
            <param name="property">The data class' property to sort on.</param>
            <param name="isForLeftDao">If true, the property we're sorting on comes from the left
                                       DAO.  If false, it comes from the right DAO.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.JoinSortOrder.#ctor(System.String,Azavea.Open.DAO.Criteria.SortType,System.Boolean)">
            <summary>
            A simple class that holds a sort criterion for a property from the right or left DAO.
            </summary>
            <param name="property">The data class' property to sort on.</param>
            <param name="direction">The direction to sort based on the Property.</param>
            <param name="isForLeftDao">If true, the property we're sorting on comes from the left
                                       DAO.  If false, it comes from the right DAO.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.JoinSortOrder.Flip">
            <summary>
            For some implementations, it's simpler to only implement one-sided joins.  So
            to handle right (or left) joins, you want to flip the criteria so the right
            and left daos are swapped and you can do a left (or right) join instead.
            </summary>
            <returns>A copy of this sort order with the left/right orientation swapped.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.JoinSortOrder.ToString">
            <summary>
            
                                Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                            
            </summary>
            
            <returns>
            
                                A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                            
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Joins.JoinType">
            <summary>
            This enumeration defines the possible types of join.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.JoinType.Inner">
            <summary>
            Inner join, only include when records exist in both the left DAO and the right DAO.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.JoinType.LeftOuter">
            <summary>
            Left outer join, include when records exist in the left DAO, even if they
            don't exist in the right DAO.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.JoinType.RightOuter">
            <summary>
            Right outer join, include when records exist in the right DAO, even if they
            don't exist in the left DAO.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.JoinType.Outer">
            <summary>
            Outer join, include when records exist in either the left or right DAO, even
            if they don't exist in the other DAO.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.SortType">
            <summary>
            On a sort parameter, indicates what order that field should be sorted in.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.SortType.Asc">
            <summary>
            Ascending, numeric (1 - 999) or alphabetic (A - Z) or CompareTo,
            depending on the data type and the class using the DaoCriteria.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.SortType.Desc">
            <summary>
            Descending, numeric (999 - 1) or alphabetic (Z - A) or CompareTo,
            depending on the data type and the class using the DaoCriteria.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.SortType.Computed">
            <summary>
            Indicates that this is a computed parameter (such as "Field1 + field2") and
            it should be sorted in whatever the natural order is (up to the class using
            this DaoCriteria to determine).
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.DaoCriteria">
            <summary>
            This class represents data query criteria.  Originally designed for use in the NHibernate
            helper, it is also now used in the Azavea.Database assemblies, and in theory could be
            used for any organized-data-processing (DataSets, feature classes, etc).
            
            Expressions are assumed to be added in the order you want them.
            AddEqual("x", 5);
            AddEqual("y", 4);
            AddEqual("z", 3);
            will produce "x = 5 AND y = 4 AND z = 3".
            
            Orders are considered in the order they are added, I.E. results will be sorted
            first by the first order, then the second, etc.
            
            Not every consumer of DaoCriteria is required to support every combination of
            expressions, is it up to the consumer to throw NotSupportedExceptions.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.DaoCriteria.BoolType">
            <summary>
            Whether this is an "AND" criteria or an "OR" criteria.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.DaoCriteria.Expressions">
            <summary>
            The individual expressions that make up this criteria.  Defaults to empty.
            Expressions can be added, cleared, etc.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.DaoCriteria.Orders">
            <summary>
            The list of properties to sort on.  Defaults to empty, you may add, clear, reorder, etc.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.DaoCriteria.Start">
            <summary>
            Used to limit the data returned, only data rows Start to Start + Limit will be returned.
            A value of -1 means ignore this parameter.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.DaoCriteria.Limit">
            <summary>
            Used to limit the data returned, only data rows Start to Start + Limit will be returned.
            A value of -1 means ignore this parameter.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.DaoCriteria.#ctor">
            <summary>
            Constructs a blank criteria, which will return all records unless you customize it.
            All expressions added to it will be ANDed together.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.DaoCriteria.#ctor(Azavea.Open.DAO.Criteria.BooleanOperator)">
            <summary>
            Constructs a blank criteria, which will return all records unless you customize it.
            </summary>
            <param name="howToAddExpressions">How expressions will be added together.  Determines
                                              if we do exp1 AND exp2 AND exp3, or if we do
                                              exp1 OR exp2 OR exp3.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.DaoCriteria.#ctor(Azavea.Open.DAO.Criteria.IExpression)">
            <summary>
            Constructs a criteria with one expression.  May be handy for cases
            where you only need one expression.
            </summary>
            <param name="firstExpr">The first expression to add.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.DaoCriteria.#ctor(Azavea.Open.DAO.Criteria.IExpression,Azavea.Open.DAO.Criteria.BooleanOperator)">
            <summary>
            Constructs a criteria with one expression.
            </summary>
            <param name="firstExpr">The first expression to add.</param>
            <param name="howToAddExpressions">How expressions will be added together.  Determines
                                              if we do exp1 AND exp2 AND exp3, or if we do
                                              exp1 OR exp2 OR exp3.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.DaoCriteria.Clear">
            <summary>
            Completely clears the object so that it may be used over again.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.DaoCriteria.CopyFrom(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Makes this DaoCriteria into a copy of the other one.  Any existing
            orders, expressions, etc. on this one are lost.
            </summary>
            <param name="other">Criteria to copy everything from.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.EqualExpression">
            <summary>
            Property == Value.  Does not accept wild cards.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.EqualExpression.#ctor(System.String,System.Object)">
            <summary>
            Property == PropertyValue.  Does not accept wild cards.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May be null (to check if the field is null).</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.EqualExpression.#ctor(System.String,System.Object,System.Boolean)">
            <summary>
            Property == PropertyValue.  Does not accept wild cards.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May be null (to check if the field is null).</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.EqualExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.EqualInsensitiveExpression">
            <summary>
            Same as equals, but will do a case-insensitve comparison ("A" == "a").
            Note that in some data sources, equals may already be case-insensitive.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.EqualInsensitiveExpression.#ctor(System.String,System.Object)">
            <summary>
            Property == PropertyValue, case-insensitively.  Does not accept wild cards.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May be null (to check if the field is null).</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.EqualInsensitiveExpression.#ctor(System.String,System.Object,System.Boolean)">
            <summary>
            Property == PropertyValue, case-insensitively.  Does not accept wild cards.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May be null (to check if the field is null).</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.EqualInsensitiveExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.GreaterExpression">
            <summary>
            Property &gt; Value
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.GreaterExpression.#ctor(System.String,System.Object)">
            <summary>
            Property &gt; Value
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.GreaterExpression.#ctor(System.String,System.Object,System.Boolean)">
            <summary>
            Property &gt; Value
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
            <param name="trueOrNot">True means look for matches (I.E. &gt;),
                                    false means look for non-matches (I.E. &lt;=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.GreaterExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.GreaterExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.HandWrittenExpression">
            <summary>
            Represents a hand-written custom expression.  May be a chunk of SQL, or may be
            something else relevant to the underlying data access layer.
            
            This is both a very powerful and very dangerous expression; it allows you
            to construct complicated logic, but you can easily pass invalid input (that
            doesn't parse), sloppy input (hard coded table / column names), or even
            evil input (sql injection).
            
            MAKE SURE to sanitize any user input that makes its way into this expression!
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.HandWrittenExpression.Expression">
            <summary>
            The expression text.  Can be almost anything, as long as it means
            something to the underlying Dao layer.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.HandWrittenExpression.Parameters">
            <summary>
            Parameters for the expression, if any.  If none, may be null or empty.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.HandWrittenExpression.#ctor(System.String)">
            <summary>
            Represents a hand-written custom expression.  May be a chunk of SQL, or may be
            something else relevant to the underlying data access layer.
            
            This is both a very powerful and very dangerous expression; it allows you
            to construct complicated logic, but you can easily pass invalid input (that
            doesn't parse), sloppy input (hard coded table / column names), or even
            evil input (sql injection).
            
            MAKE SURE to sanitize any user input that makes its way into this expression!
            </summary>
            <param name="expression">The expression text.  Can be almost anything, as long as it means
                                     something to the underlying Dao layer.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.HandWrittenExpression.#ctor(System.String,System.Collections.IEnumerable)">
            <summary>
            Represents a hand-written custom expression.  May be a chunk of SQL, or may be
            something else relevant to the underlying data access layer.
            
            This is both a very powerful and very dangerous expression; it allows you
            to construct complicated logic, but you can easily pass invalid input (that
            doesn't parse), sloppy input (hard coded table / column names), or even
            evil input (sql injection).
            
            MAKE SURE to sanitize any user input that makes its way into this expression!
            </summary>
            <param name="expression">The expression text.  Can be almost anything, as long as it means
                                     something to the underlying Dao layer.</param>
            <param name="parameters">Parameters for the expression, if any.  
                                     If none, may be null or empty.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.HandWrittenExpression.Invert">
            <summary>
            Since handwritten expressions are completely custom, there is no automatic
            way to invert them.  Therefore this is not supported.
            </summary>
            <returns>An exception.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.HandWrittenExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.LikeInsensitiveExpression">
            <summary>
            A looser form of Like, insensitive, when Like is not required to be (e.g., in PostgreSQL)
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LikeInsensitiveExpression.#ctor(System.String,System.Object)">
            <summary>
            A looser form of Like, insensitive, when Like is not required to be (e.g., in Postgres)
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LikeInsensitiveExpression.#ctor(System.String,System.Object,System.Boolean)">
            <summary>
            A looser form of Like, insensitive, when Like is not required to be (e.g., in Postgres)
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LikeInsensitiveExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Joins.AbstractJoinExpression">
            <summary>
            This base class just provides the TrueOrNot implementation.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Joins.IJoinExpression">
            <summary>
            A class that defines one way in which the two DAOs are related during a join.
            I.E. "left.field1 = right.field2".
            The type indicates the relationship between the fields and/or values
            being compared by an expression.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.IJoinExpression.Flip">
            <summary>
            For some implementations, it's simpler to only implement one-sided joins.  So
            to handle right (or left) joins, you want to flip the criteria so the right
            and left daos are swapped and you can do a left (or right) join instead.
            </summary>
            <returns>A copy of this expression with the left and right orientation swapped.</returns>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.AbstractJoinExpression._trueOrNot">
            <summary>
            Holds the value indicating whether this expression is negated.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.AbstractJoinExpression.#ctor(System.Boolean)">
            <summary>
            This lets you specify whether to negate this expression.
            </summary>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.AbstractJoinExpression.TrueOrNot">
            <summary>
            This tells you whether you want things that match, or things that
            don't match, this expression.
            </summary>
            <returns>True means look for matches (I.E. ==), false means look for non-matches (I.E. !=)</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.AbstractJoinExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.AbstractJoinExpression.Flip">
            <summary>
            For some implementations, it's simpler to only implement one-sided joins.  So
            to handle right (or left) joins, you want to flip the criteria so the right
            and left daos are swapped and you can do a left (or right) join instead.
            </summary>
            <returns>A copy of this expression with the left and right orientation swapped.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.AbstractJoinExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Joins.EqualJoinExpression">
            <summary>
            LeftProperty == RightProperty.  Does not accept wild cards.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Joins.AbstractOnePropertyEachJoinExpression">
            <summary>
            Base class for normal joins that use one field from both DAOs.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.AbstractOnePropertyEachJoinExpression.LeftProperty">
            <summary>
            The name of the property on the object returned by the left DAO that
            we are comparing.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.AbstractOnePropertyEachJoinExpression.RightProperty">
            <summary>
            The name of the property on the object returned by the right DAO that
            we are comparing.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.AbstractOnePropertyEachJoinExpression.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Base class for normal joins that use one field from both DAOs.
            </summary>
            <param name="leftProperty">The name of the property on the object returned by the
                                       left DAO that we are comparing.</param>
            <param name="rightProperty">The name of the property on the object returned by the
                                        right DAO that we are comparing.</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.EqualJoinExpression.#ctor(System.String,System.String)">
            <summary>
            LeftProperty == RightProperty.  Does not accept wild cards.
            </summary>
            <param name="leftProperty">The name of the property on the object returned by the
                                       left DAO that we are comparing.</param>
            <param name="rightProperty">The name of the property on the object returned by the
                                        right DAO that we are comparing.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.EqualJoinExpression.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            LeftProperty == RightProperty.  Does not accept wild cards.
            </summary>
            <param name="leftProperty">The name of the property on the object returned by the
                                       left DAO that we are comparing.</param>
            <param name="rightProperty">The name of the property on the object returned by the
                                        right DAO that we are comparing.</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.EqualJoinExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.EqualJoinExpression.Flip">
            <summary>
            For some implementations, it's simpler to only implement one-sided joins.  So
            to handle right (or left) joins, you want to flip the criteria so the right
            and left daos are swapped and you can do a left (or right) join instead.
            </summary>
            <returns>A copy of this expression with the left and right orientation swapped.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Joins.GreaterJoinExpression">
            <summary>
            LeftProperty &gt; RightProperty
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.GreaterJoinExpression.#ctor(System.String,System.String)">
            <summary>
            LeftProperty &gt; RightProperty
            </summary>
            <param name="leftProperty">The name of the property on the object returned by the
                                       left DAO that we are comparing.</param>
            <param name="rightProperty">The name of the property on the object returned by the
                                        right DAO that we are comparing.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.GreaterJoinExpression.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            LeftProperty &gt; RightProperty
            </summary>
            <param name="leftProperty">The name of the property on the object returned by the
                                       left DAO that we are comparing.</param>
            <param name="rightProperty">The name of the property on the object returned by the
                                        right DAO that we are comparing.</param>
            <param name="trueOrNot">True means look for matches (I.E. &gt;),
                                    false means look for non-matches (I.E. &lt;=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.GreaterJoinExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.GreaterJoinExpression.Flip">
            <summary>
            For some implementations, it's simpler to only implement one-sided joins.  So
            to handle right (or left) joins, you want to flip the criteria so the right
            and left daos are swapped and you can do a left (or right) join instead.
            </summary>
            <returns>A copy of this expression with the left and right orientation swapped.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria">
            <summary>
            This class defines how to join two FastDAOs together.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria._log">
            <summary>
            log4net logger for logging any appropriate messages.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.LeftCriteria">
            <summary>
            These are the criteria applied to the left DAO's records by themselves.
            I.E. only return rows where left.field == 5.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.RightCriteria">
            <summary>
            These are the criteria applied to the right DAO's records by themselves.
            I.E. only return rows where right.field is not null.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.Expressions">
            <summary>
            The individual expressions that make up this criteria, defaults to empty.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.Orders">
            <summary>
            The list of properties to sort on, defaults to empty.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.BoolType">
            <summary>
            Whether this is an "AND" criteria or an "OR" criteria.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.TypeOfJoin">
            <summary>
            Whether this is an inner join, left join, etc.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.Start">
            <summary>
            Used to limit the data returned, only data rows Start to Start + Limit will be returned.
            A value of -1 means ignore this parameter.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.Limit">
            <summary>
            Used to limit the data returned, only data rows Start to Start + Limit will be returned.
            A value of -1 means ignore this parameter.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.#ctor">
            <summary>
            Constructs a blank inner join criteria, which will return all records unless you customize it.
            All expressions added to it will be ANDed together.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.#ctor(Azavea.Open.DAO.Criteria.Joins.IJoinExpression)">
            <summary>
            Constructs an inner join criteria with one expression.  May be handy for cases
            where you only need one expression.
            </summary>
            <param name="firstExpr">The first expression to add.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.#ctor(Azavea.Open.DAO.Criteria.BooleanOperator)">
            <summary>
            Constructs a blank inner join criteria, which will return all records unless you customize it.
            </summary>
            <param name="howToAddExpressions">How expressions will be added together.  Determines
                                              if we do exp1 AND exp2 AND exp3, or if we do
                                              exp1 OR exp2 OR exp3.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.#ctor(Azavea.Open.DAO.Criteria.Joins.IJoinExpression,Azavea.Open.DAO.Criteria.BooleanOperator)">
            <summary>
            Constructs an inner join criteria with one expression.
            </summary>
            <param name="firstExpr">The first expression to add.</param>
            <param name="howToAddExpressions">How expressions will be added together.  Determines
                                              if we do exp1 AND exp2 AND exp3, or if we do
                                              exp1 OR exp2 OR exp3.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.#ctor(Azavea.Open.DAO.Criteria.Joins.JoinType)">
            <summary>
            Constructs a blank criteria, which will return all records unless you customize it.
            All expressions added to it will be ANDed together.
            </summary>
            <param name="typeOfJoin">Is this an inner join, left join, etc.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.#ctor(Azavea.Open.DAO.Criteria.Joins.JoinType,Azavea.Open.DAO.Criteria.Joins.IJoinExpression)">
            <summary>
            Constructs a criteria with one expression.  May be handy for cases
            where you only need one expression.
            </summary>
            <param name="firstExpr">The first expression to add.</param>
            <param name="typeOfJoin">Is this an inner join, left join, etc.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.#ctor(Azavea.Open.DAO.Criteria.Joins.JoinType,Azavea.Open.DAO.Criteria.BooleanOperator)">
            <summary>
            Constructs a blank criteria, which will return all records unless you customize it.
            </summary>
            <param name="howToAddExpressions">How expressions will be added together.  Determines
                                              if we do exp1 AND exp2 AND exp3, or if we do
                                              exp1 OR exp2 OR exp3.</param>
            <param name="typeOfJoin">Is this an inner join, left join, etc.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.#ctor(Azavea.Open.DAO.Criteria.Joins.JoinType,Azavea.Open.DAO.Criteria.Joins.IJoinExpression,Azavea.Open.DAO.Criteria.BooleanOperator)">
            <summary>
            Constructs a criteria with one expression.
            </summary>
            <param name="firstExpr">The first expression to add.</param>
            <param name="howToAddExpressions">How expressions will be added together.  Determines
                                              if we do exp1 AND exp2 AND exp3, or if we do
                                              exp1 OR exp2 OR exp3.</param>
            <param name="typeOfJoin">Is this an inner join, left join, etc.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.Clear">
            <summary>
            Completely clears the object so that it may be used over again.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.Flip">
            <summary>
            For some implementations, it's simpler to only implement one-sided joins.  So
            to handle right (or left) joins, you want to flip the criteria so the right
            and left daos are swapped and you can do a left (or right) join instead.
            </summary>
            <returns>This criteria converted from a left to a right join, or vice versa.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria.ToString">
            <summary>
            
                                Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                            
            </summary>
            
            <returns>
            
                                A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
                            
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Joins.LesserJoinExpression">
            <summary>
            LeftProperty &lt; RightProperty
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.LesserJoinExpression.#ctor(System.String,System.String)">
            <summary>
            LeftProperty &lt; RightProperty
            </summary>
            <param name="leftProperty">The name of the property on the object returned by the
                                       left DAO that we are comparing.</param>
            <param name="rightProperty">The name of the property on the object returned by the
                                        right DAO that we are comparing.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.LesserJoinExpression.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            LeftProperty &lt; RightProperty
            </summary>
            <param name="leftProperty">The name of the property on the object returned by the
                                       left DAO that we are comparing.</param>
            <param name="rightProperty">The name of the property on the object returned by the
                                        right DAO that we are comparing.</param>
            <param name="trueOrNot">True means look for matches (I.E. &lt;),
                                    false means look for non-matches (I.E. &gt;=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.LesserJoinExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Joins.LesserJoinExpression.Flip">
            <summary>
            For some implementations, it's simpler to only implement one-sided joins.  So
            to handle right (or left) joins, you want to flip the criteria so the right
            and left daos are swapped and you can do a left (or right) join instead.
            </summary>
            <returns>A copy of this expression with the left and right orientation swapped.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.LesserExpression">
            <summary>
            Property &lt; Value
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LesserExpression.#ctor(System.String,System.Object)">
            <summary>
            Property &lt; Value
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LesserExpression.#ctor(System.String,System.Object,System.Boolean)">
            <summary>
            Property &lt; Value
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
            <param name="trueOrNot">True means look for matches (I.E. &lt;),
                                    false means look for non-matches (I.E. &gt;=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LesserExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LesserExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.LikeExpression">
            <summary>
            A looser form of equals, may be case insensitive, and allowing wild cards.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LikeExpression.#ctor(System.String,System.Object)">
            <summary>
            A looser form of equals, may be case insensitive, and allowing wild cards.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LikeExpression.#ctor(System.String,System.Object,System.Boolean)">
            <summary>
            A looser form of equals, may be case insensitive, and allowing wild cards.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="value">The value to check for.  May not be null.</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.LikeExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.PropertyInListExpression">
            <summary>
            Property is equal to one of the values in the given list of values.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.PropertyInListExpression.Values">
            <summary>
            The values to check for.  An empty list will always mean "false".
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.PropertyInListExpression.#ctor(System.String,System.Collections.IEnumerable)">
            <summary>
            Property is equal to one of the values in the given IEnumerable of values.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="values">The values to check for.
                                 May not be null.  An empty list will always mean "false".</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.PropertyInListExpression.#ctor(System.String,System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Property is equal to one of the values in the given IList of values.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="values">The values to check for.
                                 May not be null.  An empty list will always mean "false".</param>
            <param name="trueOrNot">True means look for matches (I.E. ==),
                                    false means look for non-matches (I.E. !=)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.PropertyInListExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.ContainsExpression">
            <summary>
            The feature is completely contained by the criteria shape.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.AbstractSingleShapeExpression">
            <summary>
            Base class for expressions that have a single geometry criteria.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Spatial.AbstractSingleShapeExpression.Shape">
            <summary>
            This is what you want records' shapes to relate to.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.AbstractSingleShapeExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Boolean)">
            <summary>
            Create an expression on a single property relating to a single shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">This is what you want records' shapes to relate to.</param>
            <param name="trueOrNot">True means look for matches (I.E. does relate),
                                    False means look for non-matches (I.E. does not relate)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.AbstractSingleShapeExpression.ToString">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.ContainsExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry)">
            <summary>
            The feature completely contains the criteria shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">This is what you want records' shapes to contain.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.ContainsExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Boolean)">
            <summary>
            The feature completely contains the criteria shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">This is what you want records' shapes to contain.</param>
            <param name="trueOrNot">True means look for matches (I.E. contains),
                                    False means look for non-matches (I.E. does not contain)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.ContainsExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.AbstractDistanceExpression">
            <summary>
            Base class for comparing linear distance between the given shape
            and the feature against a cutoff.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Spatial.AbstractDistanceExpression.Distance">
            <summary>
            The distance we're comparing against.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.AbstractDistanceExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double,System.Boolean)">
            <summary>
            Base class for comparing linear distance between the given shape
            and the feature against a cutoff.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance we're comparing against.</param>
            <param name="trueOrNot">True means look for matches,
                                    False means look for non-matches</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.AbstractDistanceExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.AbstractDistanceSphereExpression">
            <summary>
            Base class for comparing curved distance along a spherical surface
            between the given shape and the feature, against a cutoff.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Criteria.Spatial.AbstractDistanceSphereExpression.Distance">
            <summary>
            The distance we're comparing against.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.AbstractDistanceSphereExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double,System.Boolean)">
            <summary>
            Base class for comparing curved distance along a spherical surface
            between the given shape and the feature, against a cutoff.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance we're comparing against.</param>
            <param name="trueOrNot">True means look for matches,
                                    False means look for non-matches</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.AbstractDistanceSphereExpression.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.GreaterDistanceExpression">
            <summary>
            Looks for features greater than the given distance from the given shape.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.GreaterDistanceExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double)">
            <summary>
            Looks for features greater than the given distance from the given shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance must be greater than this.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.GreaterDistanceExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double,System.Boolean)">
            <summary>
            Looks for features greater than the given distance from the given shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance must be greater than this.</param>
            <param name="trueOrNot">True means look for matches (I.E. &gt; distance),
                                    False means look for non-matches (I.E. &lt;= distance)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.GreaterDistanceExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.GreaterDistanceSphereExpression">
            <summary>
            Looks for features greater than the given distance from the given shape,
            on a spherical surface.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.GreaterDistanceSphereExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double)">
            <summary>
            Looks for features greater than the given distance from the given shape,
            on a spherical surface.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance must be greater than this.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.GreaterDistanceSphereExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double,System.Boolean)">
            <summary>
            Looks for features greater than the given distance from the given shape,
            on a spherical surface.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance must be greater than this.</param>
            <param name="trueOrNot">True means look for matches (I.E. &gt; distance),
                                    False means look for non-matches (I.E. &lt;= distance)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.GreaterDistanceSphereExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.IntersectsExpression">
            <summary>
            Any part of the feature touches or overlaps the criteria shape.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.IntersectsExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry)">
            <summary>
            Any part of the feature touches or overlaps the criteria shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">This is what you want records' shapes to intersect with.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.IntersectsExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Boolean)">
            <summary>
            Any part of the feature touches or overlaps the criteria shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">This is what you want records' shapes to intersect with.</param>
            <param name="trueOrNot">True means look for matches (I.E. does intersect),
                                    False means look for non-matches (I.E. does not intersect)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.IntersectsExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.LesserDistanceExpression">
            <summary>
            Looks for features less than the given distance from the given shape.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.LesserDistanceExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double)">
            <summary>
            Looks for features less than the given distance from the given shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance must be less than this.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.LesserDistanceExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double,System.Boolean)">
            <summary>
            Looks for features less than the given distance from the given shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance must be less than this.</param>
            <param name="trueOrNot">True means look for matches (I.E. &lt; distance),
                                    False means look for non-matches (I.E. &gt;= distance)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.LesserDistanceExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.LesserDistanceSphereExpression">
            <summary>
            Looks for features less than the given distance from the given shape,
            on a spherical surface.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.LesserDistanceSphereExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double)">
            <summary>
            Looks for features less than the given distance from the given shape,
            on a spherical surface.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance must be less than this.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.LesserDistanceSphereExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Double,System.Boolean)">
            <summary>
            Looks for features less than the given distance from the given shape,
            on a spherical surface.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">The shape we're measuring distance from.</param>
            <param name="distance">The distance must be less than this.</param>
            <param name="trueOrNot">True means look for matches (I.E. &lt; distance),
                                    False means look for non-matches (I.E. &gt;= distance)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.LesserDistanceSphereExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Criteria.Spatial.WithinExpression">
            <summary>
            The feature is completely contained by the criteria shape.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.WithinExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry)">
            <summary>
            The feature is completely within the criteria shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">This is what you want records' shapes to be within.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.WithinExpression.#ctor(System.String,GeoAPI.Geometries.IGeometry,System.Boolean)">
            <summary>
            The feature is completely within the criteria shape.
            </summary>
            <param name="property">The data class' property/field being compared.
                                   May not be null.</param>
            <param name="shape">This is what you want records' shapes to be within.</param>
            <param name="trueOrNot">True means look for matches (I.E. is within),
                                    False means look for non-matches (I.E. is not within)</param>
        </member>
        <member name="M:Azavea.Open.DAO.Criteria.Spatial.WithinExpression.Invert">
            <summary>
            Produces an expression that is the exact opposite of this expression.
            The new expression should exclude everything this one includes, and
            include everything this one excludes.
            </summary>
            <returns>The inverse of this expression.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Exceptions.BadDaoConfigurationException">
            <summary>
            This is the type of exception thrown by DAO methods when unable to read
            their config (or the values in it make no sense).
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.BadDaoConfigurationException.#ctor(System.String)">
            <summary>
            Creates an exception indicating the configuration was no good.
            </summary>
            <param name="message">What was wrong with the configuration.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Exceptions.BadDaoConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an exception indicating the configuration was no good.
            </summary>
            <param name="message">What was wrong with the configuration.</param>
            <param name="innerException">Exception that was thrown (if any, may be null).</param>
        </member>
        <member name="T:Azavea.Open.DAO.IDaQuery">
            <summary>
            This is an interface that defines a query that can be run by an IDaLayer.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IDaQuery.Clear">
            <summary>
            Clears the contents of the query, allowing the object to be reused.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.IDaJoinableLayer">
            <summary>
            If the layer supports joins natively (such as SQL statements in the database)
            it will implement this interface.
            
            NOTE on transactions: The methods on the interface accept transactions,
            but if your data source does not support transactions (or you have not
            yet implemented support), you may ignore that parameter as long as your
            equivilent IConnectionDescriptor is not an ITransactionalConnectionDescriptor.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IDaJoinableLayer.CanJoin``1(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IConnectionDescriptor,Azavea.Open.DAO.ClassMapping)">
            <summary>
            This returns whether or not this layer can perform the requested
            join natively.  This lets a layer that can have native joins determine
            whether this particular join is able to be done natively.
            </summary>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <param name="crit">The criteria specifying the requested join.</param>
            <param name="rightConn">The connection info for the other DAO we're joining with.</param>
            <param name="rightMapping">Class mapping for the right table we would be querying against.</param>
            <returns>True if we can perform the join natively, false if we cannot.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaJoinableLayer.CreateJoinQuery(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.ClassMapping)">
            <summary>
            This is not guaranteed to succeed unless CanJoin(crit, rightDao) returns true.
            </summary>
            <param name="crit">The criteria specifying the requested join.</param>
            <param name="leftMapping">Class mapping for the left table we're querying against.</param>
            <param name="rightMapping">Class mapping for the right table we're querying against.</param>
        </member>
        <member name="M:Azavea.Open.DAO.IDaJoinableLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.ClassMapping)">
            <summary>
            This performs a count instead of an actual query.  Depending on the data access layer
            implementation, this may or may not be significantly faster than actually executing
            the normal query and seeing how many results you get back.  Generally it should be
            faster.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">The criteria specifying the requested join.</param>
            <param name="leftMapping">Class mapping for the left table we're querying against.</param>
            <param name="rightMapping">Class mapping for the right table we're querying against.</param>
            <returns>The number of results that you would get if you ran the actual query.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.IDaJoinQuery">
            <summary>
            This is an interface that defines a join query that can be run by an IDaJoinableLayer.
            Since the layer defines what (if any) table aliases are used, it needs a way to
            communicate what (if anything) the columns in the data reader will be prefixed with.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.IDaJoinQuery.GetLeftColumnPrefix">
            <summary>
            The prefix that should be used to get the left table's columns out of the IDataReader
            when accessing them by name.
            </summary>
            <returns>The prefix for columns in the left table (I.E. "left_table.")</returns>
        </member>
        <member name="M:Azavea.Open.DAO.IDaJoinQuery.GetRightColumnPrefix">
            <summary>
            The prefix that should be used to get the right table's columns out of the IDataReader
            when accessing them by name.
            </summary>
            <returns>The prefix for columns in the right table (I.E. "right_table.")</returns>
        </member>
        <member name="T:Azavea.Open.DAO.IUntypedJoinResult">
            <summary>
            For simplicity's sake, it is possible you don't actually care (or don't know) what type
            of objects you're dealing with.  In that case, you can use this interface.
            </summary>
        </member>
        <member name="P:Azavea.Open.DAO.IUntypedJoinResult.LeftObject">
            <summary>
            The object from the left side of the join.  May be null if the join
            was an outer join.
            </summary>
        </member>
        <member name="P:Azavea.Open.DAO.IUntypedJoinResult.RightObject">
            <summary>
            The object from the right side of the join.  May be null if the join
            was an outer join.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.JoinResult`2">
            <summary>
            A join query returns objects representing a row from both DAOs.
            This object holds the two objects together.
            </summary>
            <typeparam name="L">The object type returned by the left DAO.</typeparam>
            <typeparam name="R">The object type returned by the right DAO.</typeparam>
        </member>
        <member name="F:Azavea.Open.DAO.JoinResult`2.Left">
            <summary>
            The object from the left side of the join.  May be null if the join
            was an outer join.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.JoinResult`2.Right">
            <summary>
            The object from the right side of the join.  May be null if the join
            was an outer join.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.JoinResult`2.#ctor(`0,`1)">
            <summary>
            Creates a JoinResult.
            </summary>
            <param name="leftVal">The object from the left side of the join.
                                  May be null if the join was an outer join.</param>
            <param name="rightVal">The object from the right side of the join.  
                                   May be null if the join was an outer join.</param>
        </member>
        <member name="M:Azavea.Open.DAO.JoinResult`2.ToString">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.JoinResult`2.Flip">
            <summary>
            For some implementations, it's simpler to only implement one-sided joins.  So
            to handle right (or left) joins, you want to flip the criteria so the right
            and left daos are swapped and you can do a left (or right) join instead.  Having
            this method here allows the results of such a flipped query to be flipped back,
            so you can return the correct result.
            </summary>
            <returns>A copy of this result with the left/right values swapped.</returns>
        </member>
        <member name="P:Azavea.Open.DAO.JoinResult`2.LeftObject">
            <summary>
            The object from the left side of the join.  Returns the same exact thing
            as ".Left", but cast to an object.  May be null if the join
            was an outer join.
            </summary>
        </member>
        <member name="P:Azavea.Open.DAO.JoinResult`2.RightObject">
            <summary>
            The object from the right side of the join.  Returns the same exact thing
            as ".Right", but cast to an object.  May be null if the join
            was an outer join.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Memory.MemoryDescriptor">
            <summary>
            Describes a connection to "memory".  This is mostly intended as a test
            implementation, the data source is just a structure in memory, but it is
            possible this will have some practical applications as well.
            
            Two connections using the same uid will hit the same in-memory collection
            of objects.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Memory.MemoryDescriptor.Uid">
            <summary>
            The ID of the in-memory store this descriptor connects to.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDescriptor.#ctor(Azavea.Open.Common.Config,System.String,Azavea.Open.DAO.ConnectionInfoDecryptionDelegate)">
            <summary>
            Populates the descriptor's values from a config file.
            </summary>
            <param name="config">Config to get params from.</param>
            <param name="component">Section of the config XML to look in for db params.</param>
            <param name="decryptionDelegate">Delegate to call to decrypt password fields.
                                             May be null if passwords are in plain text.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDescriptor.#ctor(System.String)">
            <summary>
            Instantiate an in-memory datastore connection.
            </summary>
            <param name="uid">The ID of the in-memory store this descriptor connects to.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDescriptor.ToCompleteString">
            <summary>
            Since we often need to represent database connection info as strings,
            child classes must implement ToCompleteString() such that this.Equals(that) and
            this.ToCompleteString().Equals(that.ToCompleteString()) will behave the same.
            </summary>
            <returns>A string representation of all of the connection info.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDescriptor.ToCleanString">
            <summary>
            This method is similar to ToString, except it will not contain any
            "sensitive" information, I.E. passwords.
            
            This method is intended to be used for logging or error handling, where
            we do not want to display passwords to (potentially) just anyone, but
            we do want to indicate what DB connection we were using.
            </summary>
            <returns>A string representation of most of the connection info, except
                     passwords or similar items that shouldn't be shown.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDescriptor.CreateDataAccessLayer">
            <summary>
            Returns the appropriate data access layer for this connection.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Memory.MemoryDaLayer">
            <summary>
            Data access layer implementation that simply stores objects in memory.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Unqueryable.UnqueryableDaLayer">
            <summary>
            A base class for data access layers that have no native query support
            and instead have to manually implement querying.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Unqueryable.UnqueryableDaLayer._queryCache">
            <summary>
            Cache used to store the queries for reuse.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDaLayer.#ctor(Azavea.Open.DAO.IConnectionDescriptor,System.Boolean)">
            <summary>
            Instantiates the data access layer with the connection descriptor for the data source.
            </summary>
            <param name="connDesc">The connection descriptor that is being used by this FastDaoLayer.</param>
            <param name="supportsNumRecords">If true, methods that return numbers of records affected will be
                                            returning accurate numbers.  If false, they will probably return
                                            FastDAO.UNKNOWN_NUM_ROWS.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDaLayer.CreateQuery(Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Builds the query based on a serializable criteria.  The Query object is particular to
            the implementation, but may contain things like the parameters parsed out, or whatever
            makes sense to this FastDaoLayer.  You can think of this method as a method to convert
            from the generic DaoCriteria into the specific details necessary for querying.
            </summary>
            <param name="crit">The criteria to use to find the desired objects.</param>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <returns>A query that can be run by ExecureQuery.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDaLayer.DisposeOfQuery(Azavea.Open.DAO.IDaQuery)">
            <summary>
            Should be called when you're done with the query.  Allows us to cache the
            objects for reuse.
            </summary>
            <param name="query">Query you're done using.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.#ctor(Azavea.Open.DAO.IConnectionDescriptor)">
            <summary>
            Create a new memory store.
            </summary>
            <param name="connDesc">Connection descriptor to use with this layer.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.Delete(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Deletes a data object record using the mapping and criteria for what's deleted.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table from which to delete.</param>
            <param name="crit">Criteria for deletion.  NOTE: Only the expressions are observed,
                               other things (like "order" or start / limit) are ignored.
                               WARNING: A null or empty (no expression) criteria will 
                               delete ALL records!</param>
            <returns>The number of records affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.Truncate(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Deletes all contents of the table.  Faster for large tables than DeleteAll,
            but requires greater permissions.  For layers that do not support this, the
            behavior should be the same as calling Delete(null, mapping).
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.Insert(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Inserts a data object record using the "table" and a list of column/value pairs.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="propValues">A dictionary of "column"/value pairs for the object to insert.</param>
            <returns>The number of records affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.InsertBatch(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.List{System.Collections.Generic.IDictionary{System.String,System.Object}})">
            <summary>
            Inserts a list of data object records of the same type.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="propValueDictionaries">A list of dictionaries of column/value pairs.  
                                                Each item in the list should represent the dictionary of column/value pairs for 
                                                each respective object being inserted.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.Update(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Updates a data object record using the "table" and a list of column/value pairs.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="crit">All records matching this criteria will be updated per the dictionary of
                               values.</param>
            <param name="propValues">A dictionary of column/value pairs for all non-ID columns to be updated.</param>
            <returns>The number of records affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.UpdateBatch(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.List{Azavea.Open.DAO.Criteria.DaoCriteria},System.Collections.Generic.List{System.Collections.Generic.IDictionary{System.String,System.Object}})">
            <summary>
            Updates a list of data object records of the same type.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table or other data container we're dealing with.</param>
            <param name="criteriaList">A list of DaoCriteria.
                                       Each item in the list should represent the criteria for 
                                       rows that will be updated per the accompanying dictionary.</param>
            <param name="propValueDictionaries">A list of dictionaries of column/value pairs.
                                              Each item in the list should represent the dictionary of non-ID column/value pairs for 
                                              each respective object being updated.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.ExecuteQuery(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.IDaQuery,Azavea.Open.DAO.Util.DataReaderDelegate,System.Collections.Hashtable)">
            <summary>
            Executes a query and invokes a method with a DataReader of results.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">Class mapping for the table we're querying against.  Optional,
                                  but not all columns may be properly typed if it is null.</param>
            <param name="query">The query to execute, should have come from CreateQuery.</param>
            <param name="invokeMe">The method to invoke with the IDataReader results.</param>
            <param name="parameters">A hashtable containing any values that need to be persisted through invoked method.
                                     The list of objects from the query will be placed here.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Gets a count of records for the given criteria.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <param name="crit">The criteria to use for "where" comparisons.</param>
            <returns>The number of results found that matched the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression})">
            <summary>
            Gets a count of records for the given criteria,
            aggregated by the given grouping expressions.  This matches "GROUP BY" behavior
            in SQL.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <param name="crit">The criteria to use for "where" comparisons.</param>
            <param name="groupExpressions">The fields/expressions to aggregate on when counting.</param>
            <returns>The number of objects that match the criteria, plus the values of those objects
                     for the fields that were aggregated on.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.GetLastAutoGeneratedId(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.String)">
            <summary>
            Finds the last generated id number for a column.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="mapping">The class mapping for the table being queried.</param>
            <param name="idCol">The ID column for which to find the last-generated ID.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.GetNextAutoGeneratedId(Azavea.Open.DAO.ClassMapping,System.String)">
            <summary>
            Finds the next generated id number for a column (for inserts for example).
            </summary>
            <param name="mapping">The class mapping for the table being queried.</param>
            <param name="idCol">The ID column for which to generate an ID.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.GetNextSequenceValue(Azavea.Open.DAO.ITransaction,System.String)">
            <summary>
            Gets the next id number from a sequence in the data source.
            </summary>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sequenceName">The name of the sequence.</param>
            <returns>The next number from the sequence.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.CreateIndex(System.String,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Indexes the data for faster queries.  Some data sources may not support indexes
            (such as CSV files), in which case this should throw a NotSupportedException.
            
            If the data source supports indexes, but support for creating them is not yet
            implemented, this should throw a NotImplementedException.
            </summary>
            <param name="name">Name of the index.  Some data sources require names for indexes,
                               and even if not this is required so the index can be deleted if desired.</param>
            <param name="mapping">ClassMapping for the data that is being indexed.</param>
            <param name="propertyNames">Names of the data properties to include in the index (in order).</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.DeleteIndex(System.String,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Removes an index on the data for slower queries (but usually faster inserts/updates/deletes).
            Some data sources may not support indexes (such as CSV files), 
            in which case this method should be a no-op.
            
            If the data source supports indexes, but support for creating them is not yet
            implemented, this should throw a NotImplementedException.
            </summary>
            <param name="name">Name of the index to delete.</param>
            <param name="mapping">ClassMapping for the data that was being indexed.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.IndexExists(System.String,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Returns whether an index with this name exists or not.  NOTE: This does NOT
            verify what properties the index is on, merely whether an index with this
            name is already present.
            </summary>
            <param name="name">Name of the index to check for.</param>
            <param name="mapping">ClassMapping for the data that may be indexed.</param>
            <returns>Whether an index with this name exists in the data source.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.CreateSequence(System.String)">
            <summary>
            Ensures the sequence exists.
            NOTE: It is not necessary to call this method, as this data store creates
            sequences on the fly when they are first accessed.
            </summary>
            <param name="name">Name of the new sequence to create.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.DeleteSequence(System.String)">
            <summary>
            Removes a sequence.
            NOTE: This data source creates seuqences on the fly when they are accessed,
            so this will have the effect that the next access of the sequence will get
            a "1" rather than the current next value.
            </summary>
            <param name="name">Name of the sequence to delete.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.SequenceExists(System.String)">
            <summary>
            Returns whether a sequence with this name exists or not.
            </summary>
            <param name="name">Name of the sequence to check for.</param>
            <returns>Whether a sequence with this name exists in the data source.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.CreateStoreHouse">
            <summary>
            Does nothing.  This data store does not support store houses.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.DeleteStoreHouse">
            <summary>
            Does nothing.  This data store does not support store houses.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.StoreHouseMissing">
            <summary>
            Always returns false.  This data store does not support store houses.
            </summary>
            <returns>Returns true if you need to call "CreateStoreHouse"
                     before storing any data.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.CreateStoreRoom(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Creates the store room specified in the connection descriptor.
            
            NOTE: It is not necessary to call this method, as this data store will
            create the store room on the fly if it does not exist.
            </summary>
            <param name="mapping">ClassMapping for the data that will be stored in this room.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.DeleteStoreRoom(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Deletes the store room specified in the connection descriptor.
            
            NOTE: This data store will create the store room on the fly when accessed, so
            this method is effectively the same as just deleting all the records.
            </summary>
            <param name="mapping">ClassMapping for the data that was stored in this room.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.StoreRoomMissing(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Always returns false.  This data store will create the storeroom on the fly
            if it is missing.
            </summary>
            <returns>Returns true if you need to call "CreateStoreRoom"
                     before storing any data.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDaLayer.GenerateClassMappingFromStoreRoom(System.String,System.Collections.Generic.IComparer{Azavea.Open.DAO.ClassMapColDefinition})">
            <summary>
            Uses some form of introspection to determine what data is stored in
            this data store, and generates a ClassMapping that can be immediately
            used with a DictionaryDAO.  As much data as practical will be populated
            on the ClassMapping, at a bare minimum the Table (typically set to
            the storeRoomName passed in, or the more correct or fully qualified version
            of that name), the TypeName (set to the storeRoomName, since we have no
            .NET type), and the "data cols" and "obj attrs" will be the list of 
            attributes / columns in the data source, mapped to themselves.
            </summary>
            <param name="storeRoomName">The name of the storeroom (I.E. table).  May be null
                                        if this data source does not use store rooms.</param>
            <param name="columnSorter">If you wish the columns / attributes to be in a particular
                                       order, supply this optional parameter.  May be null.</param>
            <returns>A ClassMapping that can be used with a DictionaryDAO.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Memory.MemoryTable">
            <summary>
            TODO: Not done yet.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Memory.MemoryTable.Indexes">
            <summary>
            TODO: Not done yet.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Memory.MemoryTable.Values">
            <summary>
            TODO: Not done yet.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Memory.AbstractMemoryIndex">
            <summary>
            Base class that handles some of the key comparison common across index types.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Memory.IMemoryIndex">
            <summary>
            Any index (single or multi-property) will implement this interface.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.IMemoryIndex.GetCardinality(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Returns a number indicating how many breaks this index has for the properties used
            in the criteria.  Roughly speaking, higher is better (though the number is an estimate,
            it is possible to have data that makes the index inefficient).  If there are multiple
            indexes, the one that returns the highest number from this method will be used.
            An index should return 1 to indicate that it offers no value for this criteria.
            </summary>
            <param name="crit">The query being run.</param>
            <returns>A number indicating "how good it would be to use this index".</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.IMemoryIndex.GetPossibleMatches(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Uses the index to return the smallest number of possible matches for this criteria.
            </summary>
            <param name="crit">The query being run.</param>
            <returns>A subset of all objects which may match the criteria.  This is as filtered as
                     this index can make it, but may contain objects that do not match the entire
                     criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.IMemoryIndex.Rebuild(System.Collections.Generic.IEnumerable{Azavea.Open.DAO.Memory.MemoryObject})">
            <summary>
            This method rebuilds the index given a new list of data objects.
            </summary>
            <param name="objects">All the objects in the data store.</param>
        </member>
        <member name="F:Azavea.Open.DAO.Memory.AbstractMemoryIndex._daLayer">
            <summary>
            Data access layer we're using, necessary for type coercion.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Memory.AbstractMemoryIndex._property">
            <summary>
            The property that this index is on.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.AbstractMemoryIndex.#ctor(Azavea.Open.DAO.Memory.MemoryDaLayer,System.String)">
            <summary>
            Base class that handles some of the key comparison common across index types.
            </summary>
            <param name="layer">The data access layer in use.</param>
            <param name="property">The property to index on.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.AbstractMemoryIndex.GetMatchingKeys(Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Gets the keys that match the expressions that are relevent to this index.
            </summary>
            <param name="crit">The query being run.</param>
            <param name="allKeys">All the key values in the index.</param>
            <returns>The values on real objects that match the criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.AbstractMemoryIndex.GetExpressionsForIndex(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            This returns none if the crit is ORed, or if there are no expressions
            on this index's property.
            </summary>
            <param name="crit">The query being run.</param>
            <returns>The expressions relevant to this index.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.AbstractMemoryIndex.SplitObjectsByProperty(System.Collections.Generic.IEnumerable{Azavea.Open.DAO.Memory.MemoryObject})">
            <summary>
            Splits a list of objects into a bunch of lists, one for each value of the index's property.
            </summary>
            <param name="objects">A list of potentially unordered objects.</param>
            <returns>Those objects grouped by this property.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.AbstractMemoryIndex.GetCardinality(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Returns a number indicating how many breaks this index has for the properties used
            in the criteria.  Roughly speaking, higher is better (though the number is an estimate,
            it is possible to have data that makes the index inefficient).  If there are multiple
            indexes, the one that returns the highest number from this method will be used.
            An index should return 1 to indicate that it offers no value for this criteria.
            </summary>
            <param name="crit">The query being run.</param>
            <returns>A number indicating "how good it would be to use this index".</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.AbstractMemoryIndex.GetPossibleMatches(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Uses the index to return the smallest number of possible matches for this criteria.
            </summary>
            <param name="crit">The query being run.</param>
            <returns>A subset of all objects which may match the criteria.  This is as filtered as
                     this index can make it, but may contain objects that do not match the entire
                     criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.AbstractMemoryIndex.Rebuild(System.Collections.Generic.IEnumerable{Azavea.Open.DAO.Memory.MemoryObject})">
            <summary>
            This method rebuilds the index given a new list of data objects.
            </summary>
            <param name="objects">All the objects in the data store.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Memory.SinglePropertyMemoryIndex">
            <summary>
            An index on a single field, keeps groups of the memory objects in a dictionary
            keyed by the values of the field.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.SinglePropertyMemoryIndex.#ctor(Azavea.Open.DAO.Memory.MemoryDaLayer,System.String,System.Collections.Generic.IEnumerable{Azavea.Open.DAO.Memory.MemoryObject})">
            <summary>
            An index on a single field, keeps groups of the memory objects in a dictionary
            keyed by the values of the field.
            </summary>
            <param name="layer">The data access layer in use.</param>
            <param name="property">The property to index on.</param>
            <param name="objects">All the objects in this index.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.SinglePropertyMemoryIndex.GetCardinality(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Returns a number indicating how many breaks this index has for the properties used
            in the criteria.  Roughly speaking, higher is better (though the number is an estimate,
            it is possible to have data that makes the index inefficient).  If there are multiple
            indexes, the one that returns the highest number from this method will be used.
            An index should return 1 to indicate that it offers no value for this criteria.
            </summary>
            <param name="crit">The query being run.</param>
            <returns>A number indicating "how good it would be to use this index".</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.SinglePropertyMemoryIndex.GetPossibleMatches(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Uses the index to return the smallest number of possible matches for this criteria.
            </summary>
            <param name="crit">The query being run.</param>
            <returns>A subset of all objects which may match the criteria.  This is as filtered as
                     this index can make it, but may contain objects that do not match the entire
                     criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.SinglePropertyMemoryIndex.Rebuild(System.Collections.Generic.IEnumerable{Azavea.Open.DAO.Memory.MemoryObject})">
            <summary>
            This method rebuilds the index given a new list of data objects.
            </summary>
            <param name="objects">All the objects in the data store.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Memory.MultiPropertyMemoryIndex">
            <summary>
            This is an index that has a nested index (I.E. an index on two or more fields).
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MultiPropertyMemoryIndex.#ctor(Azavea.Open.DAO.Memory.MemoryDaLayer,System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.IEnumerable{Azavea.Open.DAO.Memory.MemoryObject})">
            <summary>
            This is an index that has a nested index (I.E. an index on two or more fields).
            </summary>
            <param name="layer">Data access layer in use.</param>
            <param name="property">Property for this index.</param>
            <param name="nextProperties">Properties for the child indexes.  Must have at least one.</param>
            <param name="objects">All objects that will be in this index and its children.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MultiPropertyMemoryIndex.GetCardinality(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Returns a number indicating how many breaks this index has for the properties used
            in the criteria.  Roughly speaking, higher is better (though the number is an estimate,
            it is possible to have data that makes the index inefficient).  If there are multiple
            indexes, the one that returns the highest number from this method will be used.
            An index should return 1 to indicate that it offers no value for this criteria.
            </summary>
            <param name="crit">The query being run.</param>
            <returns>A number indicating "how good it would be to use this index".</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MultiPropertyMemoryIndex.GetPossibleMatches(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Uses the index to return the smallest number of possible matches for this criteria.
            </summary>
            <param name="crit">The query being run.</param>
            <returns>A subset of all objects which may match the criteria.  This is as filtered as
                     this index can make it, but may contain objects that do not match the entire
                     criteria.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MultiPropertyMemoryIndex.Rebuild(System.Collections.Generic.IEnumerable{Azavea.Open.DAO.Memory.MemoryObject})">
            <summary>
            This method rebuilds the index given a new list of data objects.
            </summary>
            <param name="objects">All the objects in the data store.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Memory.MemoryDataReader">
            <summary>
            A data reader that iterates over the objects from the memory store,
            sorting and filtering as necessary to satisfy the criteria.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader">
            <summary>
            Base class for data readers for data sources with no native query
            capability, so instead all the filtering has to happen as you read
            over the data.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Util.CachingDataReader">
            <summary>
            A base class to save copying a whole lot of common code for different IDataReader
            implementations.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.CachingDataReader._log">
            <summary>
            Logger that may be used by this class or its children.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.CachingDataReader._numCols">
            <summary>
            The number of columns that the data reader can read.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.CachingDataReader._indexesByName">
            <summary>
            The column indexes, keyed by the column name.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.CachingDataReader._namesByIndex">
            <summary>
            The column names, in order from the data source.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.CachingDataReader._valsByIndex">
            <summary>
            The values for this row, in column order.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.CachingDataReader._config">
            <summary>
            The config object passed to the constructor.  It is available in case the
            child class needs more data off of it.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.#ctor(Azavea.Open.DAO.Util.CachingDataReader.DataReaderConfig)">
            <summary>
            Create the data reader.
            </summary>
            <param name="config">The column indexes in the data, keyed by column name.  This may include
                                        columns not in the mapping.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetName(System.Int32)">
            <summary>
            Gets the name for the field to find.
            </summary>
            <returns>
            The name of the field or the empty string (""), if there is no value to return.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetDataTypeName(System.Int32)">
            <summary>
            Gets the data type information for the specified field.
            </summary>
            <returns>
            The data type information for the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetFieldType(System.Int32)">
            <summary>
            Gets the <see cref="T:System.Type" /> information corresponding to the type of <see cref="T:System.Object" /> that would be returned from <see cref="M:System.Data.IDataRecord.GetValue(System.Int32)" />.
            </summary>
            <returns>
            The <see cref="T:System.Type" /> information corresponding to the type of <see cref="T:System.Object" /> that would be returned from <see cref="M:System.Data.IDataRecord.GetValue(System.Int32)" />.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetValue(System.Int32)">
            <summary>
            Return the value of the specified field.
            </summary>
            <returns>
            The <see cref="T:System.Object" /> which will contain the field value upon return.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetValues(System.Object[])">
            <summary>
            Gets all the attribute fields in the collection for the current record.
            </summary>
            <returns>
            The number of instances of <see cref="T:System.Object" /> in the array.
            </returns>
            <param name="values">An array of <see cref="T:System.Object" /> to copy the attribute fields into. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetOrdinal(System.String)">
            <summary>
            Return the index of the named field.
            </summary>
            <returns>
            The index of the named field.
            </returns>
            <param name="name">The name of the field to find. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetBoolean(System.Int32)">
            <summary>
            Gets the value of the specified column as a Boolean.
            </summary>
            <returns>
            The value of the column.
            </returns>
            <param name="i">The zero-based column ordinal. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetByte(System.Int32)">
            <summary>
            Gets the 8-bit unsigned integer value of the specified column.
            </summary>
            <returns>
            The 8-bit unsigned integer value of the specified column.
            </returns>
            <param name="i">The zero-based column ordinal. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a stream of bytes from the specified column offset into the buffer as an array, starting at the given buffer offset.
            </summary>
            <returns>
            The actual number of bytes read.
            </returns>
            <param name="i">The zero-based column ordinal. </param>
            <param name="fieldOffset">The index within the field from which to start the read operation. </param>
            <param name="buffer">The buffer into which to read the stream of bytes. </param>
            <param name="bufferoffset">The index for <paramref name="buffer" /> to start the read operation. </param>
            <param name="length">The number of bytes to read. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetChar(System.Int32)">
            <summary>
            Gets the character value of the specified column.
            </summary>
            <returns>
            The character value of the specified column.
            </returns>
            <param name="i">The zero-based column ordinal. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads a stream of characters from the specified column offset into the buffer as an array, starting at the given buffer offset.
            </summary>
            <returns>
            The actual number of characters read.
            </returns>
            <param name="i">The zero-based column ordinal. </param>
            <param name="fieldoffset">The index within the row from which to start the read operation. </param>
            <param name="buffer">The buffer into which to read the stream of bytes. </param>
            <param name="bufferoffset">The index for <paramref name="buffer" /> to start the read operation. </param>
            <param name="length">The number of bytes to read. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetGuid(System.Int32)">
            <summary>
            Returns the GUID value of the specified field.
            </summary>
            <returns>
            The GUID value of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetInt16(System.Int32)">
            <summary>
            Gets the 16-bit signed integer value of the specified field.
            </summary>
            <returns>
            The 16-bit signed integer value of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetInt32(System.Int32)">
            <summary>
            Gets the 32-bit signed integer value of the specified field.
            </summary>
            <returns>
            The 32-bit signed integer value of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetInt64(System.Int32)">
            <summary>
            Gets the 64-bit signed integer value of the specified field.
            </summary>
            <returns>
            The 64-bit signed integer value of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetFloat(System.Int32)">
            <summary>
            Gets the single-precision floating point number of the specified field.
            </summary>
            <returns>
            The single-precision floating point number of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetDouble(System.Int32)">
            <summary>
            Gets the double-precision floating point number of the specified field.
            </summary>
            <returns>
            The double-precision floating point number of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetString(System.Int32)">
            <summary>
            Gets the string value of the specified field.
            </summary>
            <returns>
            The string value of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetDecimal(System.Int32)">
            <summary>
            Gets the fixed-position numeric value of the specified field.
            </summary>
            <returns>
            The fixed-position numeric value of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetDateTime(System.Int32)">
            <summary>
            Gets the date and time data value of the specified field.
            </summary>
            <returns>
            The date and time data value of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetData(System.Int32)">
            <summary>
            Returns an <see cref="T:System.Data.IDataReader" /> for the specified column ordinal.
            </summary>
            <returns>
            An <see cref="T:System.Data.IDataReader" />.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.IsDBNull(System.Int32)">
            <summary>
            Return whether the specified field is set to null.
            </summary>
            <returns>
            true if the specified field is set to null; otherwise, false.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.Close">
            <summary>
            Closes the <see cref="T:System.Data.IDataReader" /> Object.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetSchemaTable">
            <summary>
            Returns a <see cref="T:System.Data.DataTable" /> that describes the column metadata of the <see cref="T:System.Data.IDataReader" />.
            </summary>
            <returns>
            A <see cref="T:System.Data.DataTable" /> that describes the column metadata.
            </returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.IDataReader" /> is closed. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.NextResult">
            <summary>
            Advances the data reader to the next result, when reading the results of batch SQL statements.
            </summary>
            <returns>
            true if there are more rows; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.Read">
            <summary>
            Advances the <see cref="T:System.Data.IDataReader" /> to the next record.
            </summary>
            <returns>
            true if there are more rows; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.FetchNextRow">
            <summary>
            Moves the cursor (or whatever the implementation equivilent is) to the next row
            if there is one.
            </summary>
            <returns>Whether or not there was another row to fetch.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetCachedValue(System.Int32)">
            <summary>
            Will only ever look up the value once.
            </summary>
            <param name="i">0-based column index.</param>
            <returns>The value, or null if the column had no value.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.ClearVals">
            <summary>
            Resets the values in _valsByIndex.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Util.CachingDataReader.GetDataObject(System.Int32)">
            <summary>
            This method gets the actual data value from the actual data source.
            </summary>
            <param name="i">Column number to get, zero-based.</param>
            <returns>A primitive, string, date, NTS geometry, or null if the column
                     had no value.</returns>
        </member>
        <member name="P:Azavea.Open.DAO.Util.CachingDataReader.FieldCount">
            <summary>
            Gets the number of columns in the current row.
            </summary>
            <returns>
            When not positioned in a valid recordset, 0; otherwise, the number of columns in the current record. The default is -1.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Azavea.Open.DAO.Util.CachingDataReader.System#Data#IDataRecord#Item(System.Int32)">
            <summary>
            Gets the column located at the specified index.
            </summary>
            <returns>
            The column located at the specified index as an <see cref="T:System.Object" />.
            </returns>
            <param name="i">The zero-based index of the column to get. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:Azavea.Open.DAO.Util.CachingDataReader.System#Data#IDataRecord#Item(System.String)">
            <summary>
            Gets the column with the specified name.
            </summary>
            <returns>
            The column with the specified name as an <see cref="T:System.Object" />.
            </returns>
            <param name="name">The name of the column to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">No column with the specified name was found. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:Azavea.Open.DAO.Util.CachingDataReader.Depth">
            <summary>
            Gets a value indicating the depth of nesting for the current row.
            </summary>
            <returns>
            The level of nesting.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Azavea.Open.DAO.Util.CachingDataReader.IsClosed">
            <summary>
            Gets a value indicating whether the data reader is closed.
            </summary>
            <returns>
            true if the data reader is closed; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Azavea.Open.DAO.Util.CachingDataReader.RecordsAffected">
            <summary>
            Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.
            </summary>
            <returns>
            The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Azavea.Open.DAO.Util.CachingDataReader.DataReaderConfig">
            <summary>
            Child data readers may need to do something complex to get the values
            necessary to configure the parent class, so they should construct and
            pass a DataReaderSetup object.  This way if they need to also configure
            other values at the same time, they can create a more complicated Setup
            object that contains values used in their own constructor.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.CachingDataReader.DataReaderConfig.IndexesByName">
            <summary>
            The column indexes, keyed by the column name.  Defaults to a checked
            dictionary with case-insensitive keys, though you may override it if
            necessary.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.Layer">
            <summary>
            The data access layer we're reading from.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.Criteria">
            <summary>
            The criteria we're filtering by as we read the data.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.Mapping">
            <summary>
            The class mapping for the data objects we're returning.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.#ctor(Azavea.Open.DAO.Unqueryable.UnqueryableDaLayer,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.Util.CachingDataReader.DataReaderConfig)">
            <summary>
            Create the data reader.
            </summary>
            <param name="layer">Data access layer that will give us the data we need.</param>
            <param name="mapping">ClassMapping for the type we're returning.</param>
            <param name="criteria">Since there may be no way to filter before we read the data,
                                the reader checks each row read to see if it matches the
                                criteria, if not, it is skipped.</param>
            <param name="config">The column indexes in the data, keyed by column name.  This may include
                                        columns not in the mapping.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.PreProcessSorts">
            <summary>
            This should be called at the end of the child class constructor.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.GetDataObject(System.Int32)">
            <summary>
            This method gets the actual data value from the actual data source.
            </summary>
            <param name="i">Column number to get, zero-based.</param>
            <returns>A primitive, string, date, NTS geometry, or null if the column
                     had no value.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.FetchNextRow">
            <summary>
            Moves the cursor (or whatever the implementation equivilent is) to the next row
            if there is one.
            </summary>
            <returns>Whether or not there was another row to fetch.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.ReadRawRow">
            <summary>
            Returns the "row" from the data source, which we will then determine whether it
            matches the criteria, needs to be sorted, etc.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.DataMatchesCriteria(Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Determines whether the data in the current row matches the criteria specified.
            </summary>
            <param name="criteria">Criteria that the data has to meet to be returned.</param>
            <returns>True if so, false otherwise.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.ValueMatchesExpression(System.Object,Azavea.Open.DAO.Criteria.AbstractSinglePropertyExpression,Azavea.Open.DAO.IDaLayer)">
            <summary>
            Utility method to determine if a given value matches a particular expression.
            </summary>
            <param name="actualValue">Real value to check against the expression.</param>
            <param name="expr">Expression to compare the value against.</param>
            <param name="layer">Data access layer we're using, needed for type coercion.</param>
            <returns>True if the value does match the expression, false otherwise.</returns>
        </member>
        <member name="P:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.RecordsAffected">
            <summary>
            Gets the number of rows changed, inserted, or deleted by execution of the SQL statement.
            </summary>
            <returns>
            The number of rows changed, inserted, or deleted; 0 if no rows were affected or the statement failed; and -1 for SELECT statements.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.ColumnSortOrder">
            <summary>
            Used to keep track of the column indexes and which directions we're sorting them.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.ColumnSortOrder.ColIndex">
            <summary>
            The numeric (0-based) column index in the value array.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.ColumnSortOrder.Ascending">
            <summary>
            True for ascending sort, false for descending.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.ColumnSortOrder.#ctor(System.Int32,System.Boolean)">
            <summary>
            Create the sort order from the two params it needs.
            </summary>
            <param name="index"></param>
            <param name="ascending"></param>
        </member>
        <member name="T:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.SortableResult">
            <summary>
            Used for holding the results when we need to sort them.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.SortableResult.#ctor(System.Object[],System.Collections.Generic.IList{Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.ColumnSortOrder})">
            <summary>
            Creates a sortable result from the real value array.
            </summary>
            <param name="values"></param>
            <param name="sortOrders"></param>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.SortableResult.CopyTo(System.Object[])">
            <summary>
            Copies the result values back into the real array.
            </summary>
            <param name="dest"></param>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.SortableResult.CompareTo(Azavea.Open.DAO.Unqueryable.UnqueryableDataReader.SortableResult)">
            <summary>
                                Compares the current object with another object of the same type.
            </summary>
            <returns>
                                A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: 
                                Value 
                                Meaning 
                                Less than zero 
                                This object is less than the <paramref name="other" /> parameter.
                                Zero 
                                This object is equal to <paramref name="other" />. 
                                Greater than zero 
                                This object is greater than <paramref name="other" />. 
            </returns>
            <param name="other">
                                An object to compare with this object.
                            </param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.#ctor(Azavea.Open.DAO.Unqueryable.UnqueryableDaLayer,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.IEnumerator{Azavea.Open.DAO.Memory.MemoryObject})">
            <summary>
            Create the data reader.
            </summary>
            <param name="layer">Layer creating it.</param>
            <param name="mapping">Mapping for the class stored in the data store.</param>
            <param name="criteria">Criteria for which instances you want.</param>
            <param name="objects">Iterator over the list of objects.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.GetName(System.Int32)">
            <summary>
            Gets the name for the field to find.
            </summary>
            <returns>
            The name of the field or the empty string (""), if there is no value to return.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.GetFieldType(System.Int32)">
            <summary>
            Gets the <see cref="T:System.Type" /> information corresponding to the type of <see cref="T:System.Object" /> that would be returned from <see cref="M:System.Data.IDataRecord.GetValue(System.Int32)" />.
            </summary>
            <returns>
            The <see cref="T:System.Type" /> information corresponding to the type of <see cref="T:System.Object" /> that would be returned from <see cref="M:System.Data.IDataRecord.GetValue(System.Int32)" />.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.GetValues(System.Object[])">
            <summary>
            Gets all the attribute fields in the collection for the current record.
            </summary>
            <returns>
            The number of instances of <see cref="T:System.Object" /> in the array.
            </returns>
            <param name="values">An array of <see cref="T:System.Object" /> to copy the attribute fields into. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a stream of bytes from the specified column offset into the buffer as an array, starting at the given buffer offset.
            </summary>
            <returns>
            The actual number of bytes read.
            </returns>
            <param name="i">The zero-based column ordinal. </param>
            <param name="fieldOffset">The index within the field from which to start the read operation. </param>
            <param name="buffer">The buffer into which to read the stream of bytes. </param>
            <param name="bufferoffset">The index for <paramref name="buffer" /> to start the read operation. </param>
            <param name="length">The number of bytes to read. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads a stream of characters from the specified column offset into the buffer as an array, starting at the given buffer offset.
            </summary>
            <returns>
            The actual number of characters read.
            </returns>
            <param name="i">The zero-based column ordinal. </param>
            <param name="fieldoffset">The index within the row from which to start the read operation. </param>
            <param name="buffer">The buffer into which to read the stream of bytes. </param>
            <param name="bufferoffset">The index for <paramref name="buffer" /> to start the read operation. </param>
            <param name="length">The number of bytes to read. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.GetGuid(System.Int32)">
            <summary>
            Returns the GUID value of the specified field.
            </summary>
            <returns>
            The GUID value of the specified field.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.GetData(System.Int32)">
            <summary>
            Returns an <see cref="T:System.Data.IDataReader" /> for the specified column ordinal.
            </summary>
            <returns>
            An <see cref="T:System.Data.IDataReader" />.
            </returns>
            <param name="i">The index of the field to find. </param>
            <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount" />. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.Close">
            <summary>
            Closes the <see cref="T:System.Data.IDataReader" /> Object.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.GetSchemaTable">
            <summary>
            Returns a <see cref="T:System.Data.DataTable" /> that describes the column metadata of the <see cref="T:System.Data.IDataReader" />.
            </summary>
            <returns>
            A <see cref="T:System.Data.DataTable" /> that describes the column metadata.
            </returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Data.IDataReader" /> is closed. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.NextResult">
            <summary>
            Advances the data reader to the next result, when reading the results of batch SQL statements.
            </summary>
            <returns>
            true if there are more rows; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.ReadRawRow">
            <summary>
            Returns the "row" from the data source, which we will then determine whether it
            matches the criteria, needs to be sorted, etc.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryDataReader.GetCurrentObject">
            <summary>
            Gets the current row as a memory object rather than piecemeal.
            </summary>
            <returns>An object representing this row.</returns>
        </member>
        <member name="P:Azavea.Open.DAO.Memory.MemoryDataReader.Depth">
            <summary>
            Gets a value indicating the depth of nesting for the current row.
            </summary>
            <returns>
            The level of nesting.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Azavea.Open.DAO.Memory.MemoryDataReader.IsClosed">
            <summary>
            Gets a value indicating whether the data reader is closed.
            </summary>
            <returns>
            true if the data reader is closed; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Azavea.Open.DAO.Memory.MemoryObject">
            <summary>
            The representation of the object data while in the data store.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Memory.MemoryObject.ColValues">
            <summary>
             The values of the columns.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryObject.#ctor(Azavea.Open.DAO.ClassMapping,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Create a datastore object from the values passed in from the original object.
            </summary>
            <param name="mapping"></param>
            <param name="colValues"></param>
        </member>
        <member name="M:Azavea.Open.DAO.Memory.MemoryObject.GetKey">
            <summary>
            Returns a unique (or as unique as the original object's IDs anyway) single key.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.SqlDaDdlLayer">
            <summary>
            Base class for SQL-based data access layers that support DDL commands.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.SqlDaJoinableLayer">
            <summary>
            A base class for layers that use SQL and support joins in SQL.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.SqlDaLayer">
            <summary>
            A SQL-specific implementation of an IDaLayer.  
            Provided functionality to run data access function that are specific to data sources that take sql commands.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlDaLayer.COUNT_COL_ALIAS">
            <summary>
            The alias we use for "COUNT (*)".
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlDaLayer._connDesc">
            <summary>
            From this class on down, we can always treat it as a SqlConnectionDescriptor.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlDaLayer._sqlQueryCache">
            <summary>
            Since there are different types of query for different dao layers,
            each keeps their own cache.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlDaLayer._fullyQualifyColumnNames">
            <summary>
            Tells us whether or not to fully qualify column names ("Table.Column") in the SQL.
            This is generally harmless for actual databases, but may not always be desirable.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.SetFullyQualifyColumnNames(System.Boolean)">
            <summary>
            Sometimes it is not desirable to fully qualify column names, even for a database,
            e.g. when doing a query that is a join of foreign tables.  This allows this value
            to be set in those instances.
            </summary>
            <param name="fullyQualifyColumnNames">Whether or not to fully qualify column names.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.#ctor(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.Boolean)">
            <summary>
            Instantiates the data access layer with the connection descriptor for the DB.
            </summary>
            <param name="connDesc">The connection descriptor that is being used by this FastDaoLayer.</param>
            <param name="supportsNumRecords">If true, methods that return numbers of records affected will be
                                            returning accurate numbers.  If false, they will probably return
                                            FastDAO.UNKNOWN_NUM_ROWS.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.PreProcessPropertyValues(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Override this method if you need to do any work to convert values from the
            object's properties into normal SQL parameters.  Default implementation
            does nothing.
            
            This is called prior to inserting or updating these values in the table.
            </summary>
            <param name="table">The table these values will be inserted or updated into.</param>
            <param name="propValues">A dictionary of "column"/value pairs for the object to insert or update.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.Insert(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.Update(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.Delete(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression})">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.ReadGroupByCount(System.Collections.Hashtable,System.Data.IDataReader)">
            <summary>
            Reads the results from the data reader produced by the group by
            query, creates the GroupCountResults, and returns them in the 
            parameters collection.
            </summary>
            <param name="parameters">Input and output parameters for the method.</param>
            <param name="reader">Data reader to read from.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.GetGroupByValue(Azavea.Open.DAO.ClassMapping,System.Data.IDataReader,System.Int32,Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression)">
            <summary>
            Reads a single "group by" field value from the data reader, coerces it
            to the correct type if necessary/possible, and returns it.
            </summary>
            <param name="mapping">Mapping of class fields / names / etc.</param>
            <param name="reader">Data reader to get the value from.</param>
            <param name="number">Which group by field is this (0th, 1st, etc).</param>
            <param name="expression">The group by expression we're reading the value for.</param>
            <returns>The value to put in the GroupValues collection of the GroupCountResult.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.CreateQuery(Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.Criteria.DaoCriteria)">
            <summary>
            Builds the query based on a serializable criteria.
            </summary>
            <param name="crit">The criteria to use for "where" comparisons.</param>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <returns>A query that can be run by ExecureQuery.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.CreateQuery(System.String,System.Collections.IEnumerable,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Builds the query based on a string, such as a sql string.
            NOTE: Not all FastDaoLayers are required to support this, if it is not
            supported a NotSupportedException will be thrown.
            TODO: This will be removed when FastDAO.QueryFor and IterateOverObjects
            that take strings are removed.
            </summary>
            <param name="queryStr">The sql statement to execute that is expected to return a large
                                 number of rows.</param>
            <param name="queryParams">The parameters for the sql statement.  If there are none, this
                                       can be null.</param>
            <param name="mapping">The mapping of the table for which to build the query string.</param>
            <returns>A query that can be run by ExecureQuery.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.DisposeOfQuery(Azavea.Open.DAO.IDaQuery)">
            <summary>
            Should be called when you're done with the query.  Allows us to cache the
            objects for reuse.
            </summary>
            <param name="query">Query you're done using.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.GroupBysToStartOfQuery(Azavea.Open.DAO.SQL.SqlDaQuery,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression},Azavea.Open.DAO.ClassMapping)">
            <summary>
            Adds the group by fields to the "column" list ("column"
            since they may not all be columns) in the beginning of the
            select (I.E. "SELECT COUNT(*), Field1, Field2, etc).
            </summary>
            <param name="query">Query to append to.</param>
            <param name="groupExpressions">Group by expressions.</param>
            <param name="mapping">Class mapping for the class we're dealing with.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.GroupBysToEndOfQuery(Azavea.Open.DAO.SQL.SqlDaQuery,System.Collections.Generic.ICollection{Azavea.Open.DAO.Criteria.Grouping.AbstractGroupExpression},Azavea.Open.DAO.ClassMapping)">
            <summary>
            Adds the group by fields to the end of the query, including
            the keyword "GROUP BY" if necessary.
            </summary>
            <param name="query">Query to append to.</param>
            <param name="groupExpressions">Group by expressions.</param>
            <param name="mapping">Class mapping for the class we're dealing with.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.ExpressionsToQuery(Azavea.Open.DAO.SQL.SqlDaQuery,Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Takes a DaoCriteria, converts it to a " WHERE ..." chunk of SQL.
            The SQL will begin with a space if non-empty.
            </summary>
            <param name="queryToAddTo">Query we're adding the expression to.</param>
            <param name="crit">Serializable critera to get the expressions from.</param>
            <param name="mapping">Class mapping for the class we're dealing with.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.BoolTypeToString(Azavea.Open.DAO.Criteria.BooleanOperator)">
            <summary>
            Returns a nicely spaced AND or OR depending on the boolean type.
            </summary>
            <param name="boolType"></param>
            <returns></returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.ExpressionListToQuery(Azavea.Open.DAO.SQL.SqlDaQuery,Azavea.Open.DAO.Criteria.BooleanOperator,System.Collections.Generic.IEnumerable{Azavea.Open.DAO.Criteria.IExpression},Azavea.Open.DAO.ClassMapping,System.String)">
            <summary>
            Converts the list of expressions from this criteria into SQL, and appends to the 
            given string builder.
            </summary>
            <param name="queryToAddTo">Query we're adding the expression to.</param>
            <param name="boolType">Whether to AND or OR the expressions together.</param>
            <param name="expressions">The expressions to add to the query.</param>
            <param name="mapping">Class mapping for the class we're dealing with.</param>
            <param name="colPrefix">What to prefix column names with, I.E. "Table." for "Table.Column".
                                    May be null if no prefix is desired.  May be something other than
                                    the table name if the tables are being aliased.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.ExpressionToQuery(Azavea.Open.DAO.SQL.SqlDaQuery,Azavea.Open.DAO.Criteria.IExpression,Azavea.Open.DAO.ClassMapping,System.String,System.String)">
            <summary>
            Converts a single Expression to SQL (mapping the columns as appropriate) and appends
            to the given string builder.
            
            Remember to wrap the SQL in parends if necessary.
            </summary>
            <param name="queryToAddTo">Query we're adding the expression to.</param>
            <param name="expr">The expression.  NOTE: It should NOT be null. This method does not check.</param>
            <param name="mapping">Class mapping for the class we're dealing with.</param>
            <param name="colPrefix">What to prefix column names with, I.E. "Table." for "Table.Column".
                                    May be null if no prefix is desired.  May be something other than
                                    the table name if the tables are being aliased.</param>
            <param name="booleanOperator">The boolean operator (AND or OR) to insert before
                                          this expression.  Blank ("") if we don't need one.</param>
            <returns>Whether or not this expression modified the sql string.
                     Typically true, but may be false for special query types 
                     that use other parameters for certain types of expressions.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.OrdersToQuery(Azavea.Open.DAO.SQL.SqlDaQuery,Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Takes a DaoCriteria, converts it to an " ORDER BY ..." chunk of SQL.
            The SQL will begin with a space if non-empty.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.OrderListToSql(System.Text.StringBuilder,Azavea.Open.DAO.Criteria.DaoCriteria,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Converts the list of SortOrders from this criteria into SQL, and appends to the
            given string builder.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.ExecuteQuery(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.IDaQuery,Azavea.Open.DAO.Util.DataReaderDelegate,System.Collections.Hashtable)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.Truncate(Azavea.Open.DAO.ClassMapping)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.AppendParameter(Azavea.Open.DAO.SQL.SqlDaQuery,System.Object,System.Type)">
            <summary>
            Since it is implementation-dependent whether to use the sql parameters collection
            or not, this method should be implemented in each implementation.
            </summary>
            <param name="queryToAddTo">Query to add the parameter to.</param>
            <param name="columnType">Type of data actually stored in the DB column.  For example,
                                     Enums may be stored as strings.  May be null if no type cast
                                     is necessary.</param>
            <param name="value">Actual value that we need to append to our SQL.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.GetLastAutoGeneratedId(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.ClassMapping,System.String)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.GetNextSequenceValue(Azavea.Open.DAO.ITransaction,System.String)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaLayer.ReadScalarValue(System.Collections.Hashtable,System.Data.IDataReader)">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlDaJoinableLayer._sqlJoinQueryCache">
            <summary>
            Since there are different types of query for different dao layers,
            each keeps their own cache.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.#ctor(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.Boolean)">
            <summary>
            Instantiates the data access layer with the connection descriptor for the DB.
            </summary>
            <param name="connDesc">The connection descriptor that is being used by this FastDaoLayer.</param>
            <param name="supportsNumRecords">If true, methods that return numbers of records affected will be
                                            returning accurate numbers.  If false, they will probably return
                                            FastDAO.UNKNOWN_NUM_ROWS.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.CanJoin``1(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IConnectionDescriptor,Azavea.Open.DAO.ClassMapping)">
            <summary>
            This returns whether or not this layer can perform the requested
            join natively.  This lets a layer that can have native joins determine
            whether this particular join is able to be done natively.
            </summary>
            <typeparam name="R">The type of object returned by the other DAO.</typeparam>
            <param name="crit">The criteria specifying the requested join.</param>
            <param name="rightConn">The connection info for the other DAO we're joining with.</param>
            <param name="rightMapping">Class mapping for the right table we would be querying against.</param>
            <returns>True if we can perform the join natively, false if we cannot.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.CreateJoinQuery(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.ClassMapping)">
            <summary>
            This is not garaunteed to succeed unless CanJoin(crit, rightDao) returns true.
            </summary>
            <param name="crit">The criteria specifying the requested join.</param>
            <param name="leftMapping">Class mapping for the left table we're querying against.</param>
            <param name="rightMapping">Class mapping for the right table we're querying against.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.GetCount(Azavea.Open.DAO.ITransaction,Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.ClassMapping)">
            <summary>
            This performs a count instead of an actual query.  Depending on the data access layer
            implementation, this may or may not be significantly faster than actually executing
            the normal query and seeing how many results you get back.  Generally it should be
            faster.
            </summary>
            <param name="transaction">The transaction to do this as part of. May be null.</param>
            <param name="crit">The criteria specifying the requested join.</param>
            <param name="leftMapping">Class mapping for the left table we're querying against.</param>
            <param name="rightMapping">Class mapping for the right table we're querying against.</param>
            <returns>The number of results that you would get if you ran the actual query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.JoinExpressionsToQuery(Azavea.Open.DAO.SQL.SqlDaJoinQuery,Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,System.String,System.String,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Append all the join expressions ("ON blah = blah WHERE a.blah = 5 AND b.blah = 10" etc)
            to the query.
            </summary>
            <param name="query"></param>
            <param name="crit"></param>
            <param name="leftPrefix"></param>
            <param name="rightPrefix"></param>
            <param name="leftMapping"></param>
            <param name="rightMapping"></param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.TablesToQuery(Azavea.Open.DAO.SQL.SqlDaJoinQuery,Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,System.String,System.String,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Append the names of the tables ("BlahTable as left, FooTable as right") to the query.
            </summary>
            <param name="query"></param>
            <param name="crit"></param>
            <param name="leftAlias"></param>
            <param name="rightAlias"></param>
            <param name="leftMapping"></param>
            <param name="rightMapping"></param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.DisposeOfQuery(Azavea.Open.DAO.IDaQuery)">
            <summary>
            Override to handle join queries differently.
            </summary>
            <param name="query">Query you're done using.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.JoinOrderListToSql(System.Text.StringBuilder,Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.ClassMapping,System.String,System.String)">
            <summary>
            Converts the list of SortOrders from this criteria into SQL, and appends to the
            given string builder.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.JoinExpressionListToQuery(Azavea.Open.DAO.SQL.SqlDaQuery,Azavea.Open.DAO.Criteria.BooleanOperator,System.Collections.Generic.IEnumerable{Azavea.Open.DAO.Criteria.Joins.IJoinExpression},Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.ClassMapping,System.String,System.String)">
            <summary>
            Converts the list of expressions from this criteria into SQL, and appends to the 
            given string builder.
            </summary>
            <param name="queryToAddTo">Query we're adding the expression to.</param>
            <param name="boolType">Whether to AND or OR the expressions together.</param>
            <param name="expressions">The expressions to add to the query.</param>
            <param name="leftMapping">Class mapping for the class for the "left" table.</param>
            <param name="rightMapping">Class mapping for the class for the "right" table.</param>
            <param name="leftPrefix">What to prefix column names from the left table with,
                                    I.E. "LeftTable." for "LeftTable.Column".
                                    May be null if no prefix is desired.  May be something other than
                                    the table name if the tables are being aliased.</param>
            <param name="rightPrefix">What to prefix column names from the right table with,
                                    I.E. "RightTable." for "RightTable.Column".
                                    May be null if no prefix is desired.  May be something other than
                                    the table name if the tables are being aliased.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinableLayer.JoinExpressionToQuery(Azavea.Open.DAO.SQL.SqlDaQuery,Azavea.Open.DAO.Criteria.Joins.IJoinExpression,Azavea.Open.DAO.ClassMapping,Azavea.Open.DAO.ClassMapping,System.String,System.String,System.String)">
            <summary>
            Converts a single JoinExpression to SQL (mapping the columns as appropriate) and appends
            to the given string builder.
            
            Remember to wrap the SQL in parends if necessary.
            </summary>
            <param name="queryToAddTo">Query we're adding the expression to.</param>
            <param name="expr">The expression.  NOTE: It should NOT be null. This method does not check.</param>
            <param name="leftMapping">Class mapping for the class for the "left" table.</param>
            <param name="rightMapping">Class mapping for the class for the "right" table.</param>
            <param name="leftPrefix">What to prefix column names from the left table with,
                                    I.E. "LeftTable." for "LeftTable.Column".
                                    May be null if no prefix is desired.  May be something other than
                                    the table name if the tables are being aliased.</param>
            <param name="rightPrefix">What to prefix column names from the right table with,
                                    I.E. "RightTable." for "RightTable.Column".
                                    May be null if no prefix is desired.  May be something other than
                                    the table name if the tables are being aliased.</param>
            <param name="booleanOperator">The boolean operator (AND or OR) to insert before
                                          this expression.  Blank ("") if we don't need one.</param>
            <returns>Whether or not this expression modified the sql string.
                     Typically true, but may be false for special query types 
                     that use other parameters for certain types of expressions.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.#ctor(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.Boolean)">
            <summary>
            Instantiates the data access layer with the connection descriptor for the DB.
            </summary>
            <param name="connDesc">The connection descriptor that is being used by this FastDaoLayer.</param>
            <param name="supportsNumRecords">If true, methods that return numbers of records affected will be
                                            returning accurate numbers.  If false, they will probably return
                                            FastDAO.UNKNOWN_NUM_ROWS.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.CreateIndex(System.String,Azavea.Open.DAO.ClassMapping,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Indexes the data for faster queries.  Some data sources may not support indexes
            (such as CSV files), in which case this should throw a NotSupportedException.
            
            If the data source supports indexes, but support for creating them is not yet
            implemented, this should throw a NotImplementedException.
            </summary>
            <param name="name">Name of the index.  Some data sources require names for indexes,
                               and even if not this is required so the index can be deleted if desired.</param>
            <param name="mapping">ClassMapping for the data that is being indexed.</param>
            <param name="propertyNames">Names of the data properties to include in the index (in order).</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.DeleteIndex(System.String,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Removes an index on the data for slower queries (but usually faster inserts/updates/deletes).
            Some data sources may not support indexes (such as CSV files), 
            in which case this method should be a no-op.
            
            If the data source supports indexes, but support for deleting them is not yet
            implemented, this should throw a NotImplementedException.
            
            If there is no index with the given name, this should be a no-op.
            </summary>
            <param name="name">Name of the index to delete.</param>
            <param name="mapping">ClassMapping for the data that was being indexed.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.IndexExists(System.String,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Returns whether an index with this name exists or not.  NOTE: This does NOT
            verify what properties the index is on, merely whether an index with this
            name is already present.
            </summary>
            <param name="name">Name of the index to check for.</param>
            <param name="mapping">ClassMapping for the data that may be indexed.</param>
            <returns>Whether an index with this name exists in the data source.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.CreateSequence(System.String)">
            <summary>
            Sequences are things that automatically generate unique, usually incrementing,
            numbers.  Some data sources may not support sequences, in which case this should
            throw a NotSupportedException.
            
            If the data source supports sequences, but support for creating them is not yet
            implemented, this should throw a NotImplementedException.
            </summary>
            <param name="name">Name of the new sequence to create.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.DeleteSequence(System.String)">
            <summary>
            Removes a sequence.  Some data sources may not support sequences, 
            in which case this method should be a no-op.
            
            If the data source supports sequences, but support for deleting them is not yet
            implemented, this should throw a NotImplementedException.
            
            If there is no sequence with the given name, this should be a no-op.
            </summary>
            <param name="name">Name of the sequence to delete.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.SequenceExists(System.String)">
            <summary>
            Returns whether a sequence with this name exists or not.
            </summary>
            <param name="name">Name of the sequence to check for.</param>
            <returns>Whether a sequence with this name exists in the data source.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.CreateStoreHouse">
            <summary>
            Creates the store house specified in the connection descriptor.  If this
            data source doesn't use a store house, this method should be a no-op.
            
            If this data source DOES use store houses, but support for adding
            them is not implemented yet, this should throw a NotImplementedException.
            
            Store house typically corresponds to "database".
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.DeleteStoreHouse">
            <summary>
            Deletes the store house specified in the connection descriptor.  If this
            data source doesn't use a store house, this method should be a no-op.
            
            If this data source DOES use store houses, but support for dropping
            them is not implemented yet, this should throw a NotImplementedException.
            
            Store house typically corresponds to "database".
            
            If there is no store house with the given name, this should be a no-op.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.StoreHouseMissing">
            <summary>
            Returns true if you need to call "CreateStoreHouse" before storing any
            data.  This method is "Missing" not "Exists" because implementations that
            do not use a store house (I.E. single-file-based data access layers) can
            return "false" from this method without breaking either a user's app or the
            spirit of the method.
            
            Store house typically corresponds to "database".
            </summary>
            <returns>Returns true if you need to call "CreateStoreHouse"
                     before storing any data.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.CreateStoreRoom(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Creates the store room specified in the connection descriptor.  If this
            data source doesn't use a store room, this method should be a no-op.
            
            If this data source DOES use store rooms, but support for adding
            them is not implemented yet, this should throw a NotImplementedException.
            
            Store room typically corresponds to "table".
            </summary>
            <param name="mapping">ClassMapping for the data that will be stored in this room.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetGeneratorType(System.String,Azavea.Open.DAO.ClassMapping)">
            <summary>
            For a column, returns the type of generator used for it.
            </summary>
            <param name="col">Column to look up.</param>
            <param name="mapping">Mapping for the class we're creating a table for.</param>
            <returns>Type of generator, or GeneratorType.NONE.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.AddColDefinition(System.Text.StringBuilder,System.String,Azavea.Open.DAO.ClassMapping,System.String,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Add the definition for the given column to the create table statement.
            </summary>
            <param name="sb">Current create table statement to append to.</param>
            <param name="col">Name of the column to add a definition for.</param>
            <param name="mapping">Classmap for the class we're generating columns for.</param>
            <param name="separator">Separator to use before appending to sb.</param>
            <param name="extraStatements">If adding this column requires any additional
                                          SQL statements to be run afterwards, put them here.</param>
            <returns>Whether or not it appended anything to the string builder.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetAutoType(System.Type)">
            <summary>
            Returns the DDL for the type of an automatically incrementing column.
            Some databases only store autonums in one col type so baseType may be
            ignored.
            </summary>
            <param name="baseType">The data type of the column (nominally).</param>
            <returns>The autonumber definition string.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetAsciiStringType">
            <summary>
            Returns the SQL type used to store an ascii string in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetByteArrayType">
            <summary>
            Returns the SQL type used to store a byte array in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetFloatType">
            <summary>
            Returns the SQL type used to store a float in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetCharType">
            <summary>
            Returns the SQL type used to store a char in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetByteType">
            <summary>
            Returns the SQL type used to store a byte in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetShortType">
            <summary>
            Returns the SQL type used to store a short in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetBooleanType">
            <summary>
            Returns the SQL type used to store a boolean in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetDateTimeType">
            <summary>
            Returns the SQL type used to store a DateTime in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetDoubleType">
            <summary>
            Returns the SQL type used to store a double in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetLongType">
            <summary>
            Returns the SQL type used to store a long in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetIntType">
            <summary>
            Returns the SQL type used to store an integer in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GetStringType">
            <summary>
            Returns the SQL type used to store a "normal" (unicode) string in the DB.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.DeleteStoreRoom(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Deletes the store room specified in the connection descriptor.  If this
            data source doesn't use a store room, this method should be a no-op.
            
            If this data source DOES use store rooms, but support for adding
            them is not implemented yet, this should throw a NotImplementedException.
            
            Store room typically corresponds to "table".
            
            If there is no store room with the given name, this should be a no-op.
            </summary>
            <param name="mapping">ClassMapping for the data that was stored in this room.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.StoreRoomMissing(Azavea.Open.DAO.ClassMapping)">
            <summary>
            Returns true if you need to call "CreateStoreRoom" before storing any
            data.  This method is "Missing" not "Exists" because implementations that
            do not use a store room can return "false" from this method without
            breaking either a user's app or the spirit of the method.
            
            Store room typically corresponds to "table".
            </summary>
            <returns>Returns true if you need to call "CreateStoreRoom"
                     before storing any data.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaDdlLayer.GenerateClassMappingFromStoreRoom(System.String,System.Collections.Generic.IComparer{Azavea.Open.DAO.ClassMapColDefinition})">
            <summary>
            Uses some form of introspection to determine what data is stored in
            this data store, and generates a ClassMapping that can be immediately
            used with a DictionaryDAO.  As much data as practical will be populated
            on the ClassMapping, at a bare minimum the Table (typically set to
            the storeRoomName passed in, or the more correct or fully qualified version
            of that name), the TypeName (set to the storeRoomName, since we have no
            .NET type), and the "data cols" and "obj attrs" will be the list of 
            attributes / columns in the data source, mapped to themselves.
            </summary>
            <param name="storeRoomName">The name of the storeroom (I.E. table).  May be null
                                        if this data source does not use store rooms.</param>
            <param name="columnSorter">If you wish the columns / attributes to be in a particular
                                       order, supply this optional parameter.  May be null.</param>
            <returns>A ClassMapping that can be used with a DictionaryDAO.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.DbCommandCache">
            <summary>
            Holds DbCommands, we save them to allow us to reuse them (saves time).
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.DbCommandCache.Get(System.String,System.Data.IDbConnection)">
            <summary>
            This returns a command from the cache, or creates a new one if necessary.  
            This method is thread-safe.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.DbCommandCache.Return(System.String,System.Data.IDbConnection,System.Data.IDbCommand)">
            <summary>
            Returns a command to the cache when it is no longer used, allowing another call
            to reuse it.
            
            This method is thread-safe.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.SqlDaJoinQuery">
            <summary>
            A SQL query that joins two tables, can be run by the SqlDaLayer.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.SqlDaQuery">
            <summary>
            A "normal" SQL query, can be run by the SqlDaLayer.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlDaQuery.Sql">
            <summary>
            The SQL statement to run, hopefully parameterized.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlDaQuery.Params">
            <summary>
            Any parameters for the SQL statement.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaQuery.Clear">
            <summary>
            Clears the contents of the query, allowing the object to be reused.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaQuery.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
            
            <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinQuery.SetPrefixes(System.String,System.String)">
            <summary>
            Populates the prefix strings.
            </summary>
            <param name="left">Prefix for columns from the left table.</param>
            <param name="right">Prefix for columns from the right table.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinQuery.GetLeftColumnPrefix">
            <summary>
            The prefix that should be used to get the left table's columns out of the IDataReader
            when accessing them by name.
            </summary>
            <returns>The prefix for columns in the left table (I.E. "left_table.")</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlDaJoinQuery.GetRightColumnPrefix">
            <summary>
            The prefix that should be used to get the right table's columns out of the IDataReader
            when accessing them by name.
            </summary>
            <returns>The prefix for columns in the right table (I.E. "right_table.")</returns>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.SqlClauseWithValue">
            <summary>
            Many SQL clauses look something like this: "(colName > 5)".  However, on
            some DBs, that same clause may actually look like this: "LT_OR_EQ(5, colName)".
            To make things more complicated, you may want to not put 5 in the string, but
            use a parameter instead.  So this allows you to represent it, in the first case
            PartBeforeValue would be "(colName > " and PartAfterValue would be ")", and in
            the second case PartBeforeValue would be "LT_OR_EQ(" and PartAfterValue would
            be ", colName)".
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlClauseWithValue.PartBeforeValue">
            <summary>
            The part of the clause that comes before the value.  May be null.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlClauseWithValue.PartAfterValue">
            <summary>
            The part of the clause that comes after the value.  May be null.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlClauseWithValue.#ctor">
            <summary>
            Create a blank clause.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlClauseWithValue.#ctor(System.String,System.String)">
            <summary>
            Create a clause by specifying the before and after parts.
            </summary>
            <param name="before">The part of the clause that comes before the value.</param>
            <param name="after">The part of the clause that comes after the value.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlClauseWithValue.Clear">
            <summary>
            Sets both parts back to null.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.DbConnectionCache">
            <summary>
            Holds connections, using the connection descriptor to determine what
            request wants what connection.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.DbConnectionCache.Get(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor)">
            <summary>
            This returns a connection from the cache, or creates a new one if necessary. 
            
            This method is thread safe.
            
            This method improved one test's performance (the only one I measured) by about 20%.
            
            Since some databases cannot have more than one connection at a time, we ask the
            connection descriptor whether we can actually cache the connection or not.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.DbConnectionCache.Return(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.Data.IDbConnection)">
            <summary>
            Inserts the connection into the cache IF we don't have one already (we only cache one
            connection per unique descriptor).
            
            This method is thread safe.
            
            Due to MS Access not allowing more than one connection to have the DB locked for modifying at
            one time, any connections to Access DBs are closed and not cached.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor">
            <summary>
            This class represents the information needed to establish a connection to a data
            source that speaks SQL (presumably a database).
            
            This class, and any that extend it, should be thread safe.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.CreateDataAccessLayer">
            <summary>
            Returns the appropriate data access layer for this connection.  The default
            implementation returns a normal SQL data access layer, but this may be
            overridden in particular DB connection descriptors.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.MakeModulusClause(System.String)">
            <summary>
            Returns a modulus sql string, something like "columnName % value", except
            that the syntax is DB-specific.  Throws NotImplementedException if not yet supported
            for a particular type of connection.
            </summary>
            <param name="columnName">The column used in the clause.</param>
            <returns>The pieces of SQL that go before and after the value you wish to mod by.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.MakeSequenceValueQuery(System.String)">
            <summary>
            Since different databases have different ideas of what a sequence is, this
            allows the utility class to support sequences across all different DBs.
            </summary>
            <param name="sequenceName">The name of the sequence we're getting an ID from.</param>
            <returns>A sql string that will retrieve a sequence integer value (I.E. something like
                     "SELECT NEXTVAL FROM sequenceName")</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.MakeBitwiseAndClause(System.String)">
            <summary>
            Returns a 'bitwise and' sql string, something like "columnName &amp; value", except
            that the syntax is DB-specific.  Throws NotImplementedException if not yet supported
            for a particular type of connection.
            </summary>
            <param name="columnName">The column used in the clause.</param>
            <returns>The pieces of SQL that go before and after the value you wish to AND by.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.MakeLastAutoGeneratedIdQuery(System.String,System.String)">
            <summary>
            Gets the last id generated in an ID column for a table.  Some databases can do this
            more efficiently or correctly than the default way ("select max idcol from table").
            </summary>
            <param name="tableName">The table the ID column belongs to.</param>
            <param name="idCol">The ID column for which to get the last generated ID value.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.MakeCreateIndexCommand(System.String,System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns the SQL statement to create an index on a table.  There may be
            database-specific additional keywords required (such as "COMPUTE STATISTICS").
            The default implementation returns a simple standard-sql create index statement.
            </summary>
            <param name="indexName">Name of the index to create.</param>
            <param name="isUnique">Is this a unique index?</param>
            <param name="tableName">What table to create the index on.</param>
            <param name="columnNames">The columns included in the index.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.SupportsTruncate">
            <summary>
            Nearly every DB in the universe supports truncate, but a few (cough Access cough)
            do not.
            </summary>
            <returns>True if "truncate table blah" will work, false if you need to do
                     "delete from table blah" instead (which will be slower).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.UsePooling">
            <summary>
            Depending on the database and connection info, it may not always be appropriate to
            pool connections.  This allows the connection descriptor to decide.
            </summary>
            <returns>True if connection pooling should be used, false otherwise.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.CreateNewConnection">
            <summary>
            This method returns a database connection to the database specified by
            this connection descriptor.  This is not meant to be called by client
            code, only by the utilities in the Azavea.Database assembly.
            </summary>
            <returns>An IDbConnection of the appropriate type (OleDb, Sql Server native, etc).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.SetParametersOnCommand(System.Data.IDbCommand,System.Collections.IEnumerable)">
            <summary>
            Each driver seems to have its own way of marking parameters ("?", ":param", "@PARAM", etc).
            So, the database utilities class always uses "?" and relies on the specific descriptor to
            replace the ? with the appropriate names in the SQL, and also to set the parameters on
            the command object.
            </summary>
            <param name="cmd">Database command (with .Text already populated with sql) that needs
                              the parameters set on it.</param>
            <param name="parameters">The parameter values, in the order that the ?'s appear in the
                                     command's text.  This collection should not be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.CreateNewAdapter(System.Data.IDbCommand)">
            <summary>
            This method returns a DbDataAdapter that can be used to fill DataSets.
            </summary>
            <param name="cmd">The command that the adapter will be executing.</param>
            <returns>A DbDataAdapter of the appropriate type (OleDb, native, etc).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.NeedToAliasColumns">
            <summary>
            Does this database require that we alias the columns explicitly if we are
            aliasing the table name?  Most DBs will alias the columns for you (I.E. if you
            "SELECT ID FROM TABLE1 AS ALIAS1" then the column will be called "ALIAS1.ID", etc).
            However some require that you alias the columns specifically (cough SQLite, Access cough).
            </summary>
            <returns>True if aliasing the table names is not enough.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.NeedAsForColumnAliases">
            <summary>
            Does the database require the "AS" keyword for aliasing a column?
            Most do not, but some (MS Access) do.
            </summary>
            <returns>True if "AS" is required when aliasing a column.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.CanUseAliasInOrderClause">
            <summary>
            Once we've aliased a function (such as COUNT(*)), can we use that alias
            in the order by clause or do we need to put the function again?
            </summary>
            <returns>True if we want to use the ColumnAliasPrefix and ColumnAliasSuffix in ORDER BY clauses.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.ColumnAliasPrefix">
            <summary>
            Some databases want the " AS " keyword, some want the alias in quotes
            (cough SQLite cough), or square brackets (cough Microsoft cough), or 
            whatever.  This provides the database-specific stuff that comes before
            the alias.
            </summary>
            <returns>The keyword, quotes, brackets, etc used before the alias
                     when aliasing a column.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.ColumnAliasSuffix">
            <summary>
            Some databases want the " AS " keyword, some want the alias in quotes
            (cough SQLite cough), or square brackets (cough Microsoft cough), or 
            whatever.  This provides the database-specific stuff that comes after
            the alias.
            </summary>
            <returns>The keyword, quotes, brackets, etc used after the alias
                     when aliasing a column.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.TableAliasPrefix">
            <summary>
            Some databases want the " AS " keyword, some don't (cough Oracle cough).
            This provides the database-specific stuff that comes before the alias.
            </summary>
            <returns>The keyword, quotes, brackets, etc used before the alias
                     when aliasing a table.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.TableAliasSuffix">
            <summary>
            Some databases want the " AS " keyword, some don't (cough Oracle cough).
            This provides the database-specific stuff that comes after the alias.
            </summary>
            <returns>The keyword, quotes, brackets, etc used after the alias
                     when aliasing a table.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.FullOuterJoinKeyword">
            <summary>
            Not all databases have the same syntax for full outer joins.  Most use
            "FULL OUTER JOIN" but some do not.
            </summary>
            <returns>The key word (or words) that mean "OUTER JOIN".</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.LowerCaseFunction">
            <summary>
            UPPER and LOWER are not actually consistent across databases.
            </summary>
            <returns>The function name that converts a string to lower case.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.HasCaseInsensitiveLikeOperator">
            <summary>
            Not all databases have a case insensitive LIKE operator, such as
            ILIKE in postgres.  Some databases (SQL Server/Access) use LIKE as
            case insensitive by default.
            </summary>
            <returns>True if the database has an operator that compares
            partial value matches case-insensitively.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor.CaseInsensitiveLikeOperator">
            <summary>
            The specific operator for doing case insensitive expressions
            </summary>
            <returns>The database specific operator which supports case insensitive
            expressions.  LIKE/ILIKE for example.</returns>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.SqlTransaction">
            <summary>
            A simple implementation of an ITransaction for SQL data sources.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlTransaction.Transaction">
            <summary>
            Used by the data access layer, returns the internal object
            that can actually be used to perform transactional operations.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlTransaction.Connection">
            <summary>
            Used by the data access layer, returns the actual database
            connection that this transaction is open against.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.SQL.SqlTransaction.ConnDesc">
            <summary>
            The connection descriptor this transaction is operating against.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlTransaction.#ctor(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor)">
            <summary>
            Create the interface object from a low-level object.
            </summary>
            <param name="connDesc">The connection descriptor this is a transaction for.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlTransaction.Commit">
            <summary>
            Writes all the statements executed as part of this transaction to the
            database.  Until this is called, none of the inserts/updates/deletes
            you do will be visible to any other users of the database.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlTransaction.Rollback">
            <summary>
            Undoes all the statements executed as part of this transaction.  The
            database will be as though you never executed them.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlTransaction.Finalize">
            <summary>
            When destroyed, if we haven't been terminated, attempt to roll back.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.AbstractFastDAOTests">
            <summary>
            This is a set of tests that you can extend when you create new FastDAO plugins.
            Uses SQL to double-check that things are correct in the data source, so only
            works with SQL data sources.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._connDesc">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._nameDAO">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._nameDictDAO">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._enumDAO">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._enumDictDAO">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._boolDAO">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._boolDictDAO">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._nullDAO">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._nullDictDAO">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._hasNativeBoolean">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._canGetAutoGeneratedID">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._canVerifyWithSQL">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._supportsGroupBy">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._expectNullsFirst">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._supportsTransactions">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.AbstractFastDAOTests._transactionsLockData">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.#ctor(Azavea.Open.Common.Config,System.String,System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.#ctor(Azavea.Open.Common.Config,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.#ctor(Azavea.Open.Common.Config,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.#ctor(Azavea.Open.Common.Config,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.ResetAllTables">
            <summary>
            For child classes whose data access layers implement IDaDdlLayer, this will drop
            and recreate all the tables used by this test.  Otherwise it will just truncate them.
            
            It will then insert all rows needed for the tests.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.ResetStoreHouse(Azavea.Open.DAO.IDaLayer)">
            <summary>
            Utility method for deleting and recreating unit test databases, if possible.
            </summary>
            <param name="layer">The low-level data access layer object from a FastDAO.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.ResetTable(Azavea.Open.DAO.IDaLayer,Azavea.Open.DAO.ClassMapping)">
            <summary>
            Utility method for dropping and recreating unit test tables.
            </summary>
            <param name="layer">The low-level data access layer object from a FastDAO.</param>
            <param name="classMap">The class mapping for the table to recreate.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSimpleRead">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestEmptyNestedCriteria">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSimpleReadDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGetByPropertyInList">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGetByPropertyInListDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSimpleInsert">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSimpleInsertDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestBatchInsert">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestBatchInsertDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestInsertFindingGeneratedId">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestInsertFindingGeneratedIdDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestMultiInsert">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestMultiInsertDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSimpleUpdate">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSimpleUpdateDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestBatchUpdate">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestBatchUpdateDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestUpdateColumn">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestUpdateColumns">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSimpleDelete">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSimpleDeleteDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSimpleInsensitiveLike">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestTransactionalInsertDelete">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestTransactionalInsertDeleteDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGetCount">
            <exclude />
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGetCountDictionary">
            <exclude />
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGetCountWithSort">
            <exclude />
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGetCountWithSortDictionary">
            <exclude />
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestEnums">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestEnumsDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestBools">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestBoolsDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestNullables">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestNullablesDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestSortOnNull">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGroupByOne">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGroupByOneDesc">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGroupByOneDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGroupByOneDescDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGroupByTwo">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGroupByTwoDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGroupByThree">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestGroupByThreeDictionary">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractFastDAOTests.TestEnumInAndNotInList">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.NameClass">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.NameClass.ID">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.NameClass.Name">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.NameClass.#ctor">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.NameClass.#ctor(System.String)">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.EnumTest">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.EnumTest.HERE">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.EnumTest.IS">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.EnumTest.AN">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.EnumTest.ENUM">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.EnumClass">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.EnumClass.ID">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.EnumClass.Enum1">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.EnumClass.Enum2">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.BoolClass">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.BoolClass.ID">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.BoolClass.BoolVal">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.NullableClass">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.NullableClass.ID">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.NullableClass.BoolVal">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.NullableClass.IntVal">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.NullableClass.DateVal">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.NullableClass.FloatVal">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.AbstractJoinTests">
            <summary>
            This is a test class you can extend to test joins on any pair of DAOs.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.#ctor(Azavea.Open.DAO.FastDAO{Azavea.Open.DAO.Tests.JoinClass1},Azavea.Open.DAO.FastDAO{Azavea.Open.DAO.Tests.JoinClass2},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.ResetAllTables">
            <summary>
            For child classes whose data access layers implement IDaDdlLayer, this will drop
            and recreate all the tables used by this test.  Otherwise it will just truncate them.
            
            It will then insert all rows needed for the tests.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.AssertJoinResults``2(Azavea.Open.DAO.IFastDaoReader{``0},Azavea.Open.DAO.IFastDaoReader{``1},Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,System.String[],System.String[],System.String)">
            <summary>
            This one allows you to specify the values for each side.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.TestInnerJoinEquals">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.TestJoinStart">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.TestJoinLimit">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.TestJoinStartLimit">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test12LOuterJoinEquals">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test21LOuterJoinEquals">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test12ROuterJoinEquals">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test21ROuterJoinEquals">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test12OuterJoinEquals">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test21OuterJoinEquals">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.TestInnerJoinGreater">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test12LOuterJoinGreater">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test21LOuterJoinGreater">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test12ROuterJoinGreater">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test21ROuterJoinGreater">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test12OuterJoinGreater">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test21OuterJoinGreater">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.TestInnerJoinLesser">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test12LOuterJoinLesser">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test21LOuterJoinLesser">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test12ROuterJoinLesser">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test21ROuterJoinLesser">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test12OuterJoinLesser">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.AbstractJoinTests.Test21OuterJoinLesser">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.JoinClass1">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.JoinClass1.ID">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.JoinClass1.JoinField">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.JoinClass1.Name">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.JoinClass1.#ctor">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.JoinClass1.#ctor(System.String)">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.JoinClass1.ToString">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.JoinClass2">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.JoinClass2.#ctor">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.JoinClass2.#ctor(System.String)">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.MappingTests">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.MappingTests.TestEasyCompositeKeys">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.MappingTests.TestNHibernateCompositeKeys">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.MappingTests.TestInlineMapping">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.BaseCompositeKeyClass">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.BaseCompositeKeyClass.ID1">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.BaseCompositeKeyClass.ID2">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.BaseCompositeKeyClass.ID3">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.BaseCompositeKeyClass.Prop1">
            <exclude/>
        </member>
        <member name="F:Azavea.Open.DAO.Tests.BaseCompositeKeyClass.Prop2">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.EasyCompositeKeyClass">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.NHibernateCompositeKeyClass">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.MemoryDaoTests">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.MemoryDaoTests.#ctor">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.MemoryDaoTests.Init">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.PseudoJoinTests">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.PseudoJoinTests.#ctor">
            <exclude/>
            Use two different connection descriptors to force FastDAO to use the PseudoJoiner.
        </member>
        <member name="T:Azavea.Open.DAO.Tests.SqlUtilTests">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.SqlUtilTests.TestMakeDeleteStatement">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.SqlUtilTests.TestMakeInsertStatement">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.SqlUtilTests.TestMakeUpdateStatement">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.SqlUtilTests.TestMakeWhereClause">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.SqlUtilTests.TestTypePerformance">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.SqlUtilTests.TestGetNullableTableMappingFromSchema(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String)">
            <summary>
            Tests the classmapping generation off the nullable table schema.
            </summary>
            <param name="connDesc">Connection descriptor for your particular database.</param>
            <param name="nullableTableName">Correctly-cased name of the nullable table (some DBs
                                            are case sensitive (cough oracle, postgresql cough)</param>
        </member>
        <member name="T:Azavea.Open.DAO.Unqueryable.UnqueryableQuery">
            <summary>
            A query intended to be run against a data source that does not
            have any native query mechanism.  Therefore this class merely
            stores the criteria used for the query, to be later used when
            manually processing the contents of the data source.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Unqueryable.UnqueryableQuery.Criteria">
            <summary>
            Since the queries have to be evaluated at read time (there is no queryability
            in the data source itself, we have to merely read it and discard rows that don't match)
            there is nothing to be done to "pre-process" the criteria, we just save it
            for the reader to use.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableQuery.Clear">
            <summary>
            Clears the contents of the query, allowing the object to be reused.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Unqueryable.UnqueryableQuery.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
            
            <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Azavea.Open.DAO.Util.DataReaderDelegate">
            <summary>
            This describes a method to be executed once an IDataReader has been obtained.  This delegate
            will be called once and passed the IDataReader that was the result of the query.  It is
            up to the delegate to iterate through the results if it wants to.
            </summary>
            <param name="parameters">A hashtable containing anything at all.  This is used as
                                     a way of passing parameters to the delegate, or as a way
                                     for the delegate to return values to the function that called
                                     it.  This parameter may be null.</param>
            <param name="reader">The data reader with the results of the database query.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Tests.CriteriaTests">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.CriteriaTests.TestConstructors">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.CriteriaTests.TestOrders">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.CriteriaTests.TestSubExpressions">
            <exclude/>
        </member>
        <member name="M:Azavea.Open.DAO.Tests.CriteriaTests.TestSerialize">
            <exclude/>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.SqlConnectionUtilities">
            <summary>
            This class holds static utility methods having to do with database access.  The goal is
            twofold:
              1: To reduce the number of lines of code required to to basic database stuff (if you're
                 doing more complicated stuff, it may be appropriate to look at Azavea.Common.NHibernate
                 and consider using NHibernate).
              2: To ensure that connections are handled appropriately even in exception cases (I.E. they
                 are closed and/or returned to the pool whether or not exceptions happen).
            
            Since no one likes obnoxiously long method names, "ExceptionSafe" has been abbreviated
            as "XSafe".
            
            There are two groups of methods, the "XSafe" query/command methods and the "DataSet" methods.
            The DataSet methods are provided primarily because some things (such as .NET controls) use DataSets directly.
            
            However, in general when writing new code you should use the XSafe methods, because they use
            DataReaders which are a faster way of accessing the database than DataSets.
            
            This class currently implements fairly primitive connection pooling.  While .NET claims
            to do connection pooling for you, there is still a significant performance savings to be
            had by saving "DbConnection" objects and reusing them.  The existing connection pooling
            basically saves one connection to any database you use this class to connect to.  This
            achieves most of the savings that can be achieved with pooling, but if necessary a more
            complicated pooling scheme can be added in the future.
            Note that connection pooling is NOT used for all databases, since they may not
            support more than one "write" connection at a time.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.IEnumerable,Azavea.Open.DAO.Util.DataReaderDelegate,System.Collections.Hashtable)">
            <summary>
            This provides a way to query the DB and do something with the results without
            having to copy the "try, open, try, execute, finally, close, finally, close"
            type logic in a bunch of places.  This method correctly closes the objects
            used in the DB access in the event of an exception.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="sql">The SQL statement to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <param name="invokeMe">The method to delegate to.  If null, nothing is
                                   done with the data reader and it is just closed.</param>
            <param name="parameters">The other parameters to the delegate, in whatever
            						 form makes sense for that delegate method.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable,Azavea.Open.DAO.Util.DataReaderDelegate,System.Collections.Hashtable)">
            <summary>
            This provides a way to query the DB and do something with the results without
            having to copy the "try, open, try, execute, finally, close, finally, close"
            type logic in a bunch of places.  This method correctly closes the objects
            used in the DB access in the event of an exception.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL statement to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <param name="invokeMe">The method to delegate to.  If null, nothing is
                                   done with the data reader and it is just closed.</param>
            <param name="parameters">The other parameters to the delegate, in whatever
            						 form makes sense for that delegate method.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeStringQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single string.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The string returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeStringQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single string.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The string returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeIntQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single integer (such as SELECT COUNT).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The integer returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeIntQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single integer (such as SELECT COUNT).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The integer returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeBoolQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single boolean.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The boolean returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeBoolQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single boolean.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The boolean returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeDateQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single DateTime (such as SELECT MAX(DateField)).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The DateTime returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeDateQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single DateTime (such as SELECT MAX(DateField)).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The DateTime returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeDoubleQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single floating-point number (such as SELECT SUM(...)).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The floating-point number returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeDoubleQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single floating-point number (such as SELECT SUM(...)).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The floating-point number returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeStringListQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the other XSafe methods, except this one returns a list of
            strings (for example, SELECT NAME FROM EMPLOYEES).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>A List of strings, from the first column of the results 
            		(presumably there is only one column in the results).  If no results
            		were returned, this List will be empty.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeStringListQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the other XSafe methods, except this one returns a list of
            strings (for example, SELECT NAME FROM EMPLOYEES).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>A List of strings, from the first column of the results 
            		(presumably there is only one column in the results).  If no results
            		were returned, this List will be empty.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeIntListQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the other XSafe methods, except this one returns a list of
            integers (for example, SELECT AGE FROM EMPLOYEES).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>A List of integers, from the first column of the results 
            		(presumably there is only one column in the results).  If no results
            		were returned, this List will be empty.  Since integers are not nullable,
                    NULL VALUES WILL BE IGNORED.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeIntListQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the other XSafe methods, except this one returns a list of
            integers (for example, SELECT AGE FROM EMPLOYEES).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>A List of integers, from the first column of the results 
            		(presumably there is only one column in the results).  If no results
            		were returned, this List will be empty.  Since integers are not nullable,
                    NULL VALUES WILL BE IGNORED.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeCommand(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            non-query type SQL statement.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="sql">The SQL statement to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The number of rows affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeCommand(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            non-query type SQL statement.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL statement to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The number of rows affected.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.QueryForDataSet(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.String,System.Collections.IEnumerable)">
            <summary>
            Queries for data and populates the specified dataset.  If you already have a dataset,
            use the QueryIntoDataSet method.
            </summary>
            <param name="dataTableName">The name of the DataTable to put data into in the DataSet.
                                    May be null if you wish to use the default given by the DataAdapter.</param>
            <param name="sql">The parameterized SQL query (?'s for values).</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <param name="connDesc">The database connection descriptor.  This will be
                                   used to get the database connection.</param>
            <returns>A DataSet full of data.  Should never return null, but
            		 may return an empty dataset.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.QueryIntoDataSet(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.String,System.Collections.IEnumerable,System.Data.DataSet)">
            <summary>
            Queries for data and populates the specified dataset.  If you do not have a dataset
            already, call QueryForDataSet instead.
            </summary>
            <param name="dataTableName">The name of the DataTable to put data into in the DataSet.
                                    May be null if you wish to use the default given by the DataAdapter.</param>
            <param name="sql">The parameterized SQL query (?'s for values).</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <param name="connDesc">The database connection descriptor.  This will be
                                   used to get the database connection.</param>
            <param name="fillMe">The dataset to put data into.  Must not be null.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.TestConnection(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor)">
            <summary>
            Attempts to determine if a connection can be made using the specified connection string.
            </summary>
            <param name="connDesc">Connection descriptor to test.</param>
            <returns>True if a connection could be made, false otherwise
                     (exceptions are logged at debug level).</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.DropIndex(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String)">
            <summary>
            Drops the specified index.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="indexName">The name of the index to remove.</param>
            <returns>True if successful, false otherwise.  Any exceptions will be
                     logged as warnings.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.CreateIndex(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a non-unique index on a database table.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="indexName">Name of the index to create.</param>
            <param name="tableName">What table to create the index on.</param>
            <param name="columnNames">The columns included in the index.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.CreateIndex(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates an index on a database table.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="indexName">Name of the index to create.</param>
            <param name="isUnique">Is this a unique index?</param>
            <param name="tableName">What table to create the index on.</param>
            <param name="columnNames">The columns included in the index.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.TruncateTable(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String)">
            <summary>
            Truncates a table if supported by the DB, otherwise deletes all rows (which is
            effectively the same, but potentially a lot slower).
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="tableName">What table we want to blow away the contents of.</param>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.GetSchema(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor)">
            <summary>
            Similar to DbConnection.GetSchema, except this keeps the connection
            handling logic here in the utility class.
            </summary>
            <param name="connDesc">Connection descriptor for the database.</param>
            <returns>A DataTable, same as DbConnection.GetSchema.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.GetSchema(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.String[])">
            <summary>
            Similar to DbConnection.GetSchema, except this keeps the connection
            handling logic here in the utility class.
            </summary>
            <param name="connDesc">Connection descriptor for the database.</param>
            <param name="name">The name of the type of object you want schema info on.
                               For example, "Columns" to get info on the columns.</param>
            <param name="restrictions">A magic string array that means something to
                                       DbConnection.GetSchema.  Should be a string array
                                       of the following restrictions:
                                       [0] = Catalog
                                       [1] = Owner
                                       [2] = Table
                                       [3] = TableType
                                       Any/all may be null.</param>
            <returns>A DataTable, same as DbConnection.GetSchema.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.GenerateMappingFromSchema(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String)">
            <summary>
            Generates a simplistic classmapping (without changing any column/field names) from a
            table's schema.  Intended for times when you are transferring data without really using it,
            for example from a DB to a CSV.  Will most likely only be useful for a DictionaryDAO since
            there is no defined .NET class to map to.
            
            All column names will be returned in caps.
            </summary>
            <param name="connDesc">Connection descriptor for the database.</param>
            <param name="tableName">Name of the table to generate a mapping for.</param>
            <returns>A class mapping, the type name will be the table name, every column will be
                     mapped to a "field" of the same name, and no types will be specified.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.GenerateMappingFromSchema(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.String,System.Collections.Generic.IComparer{Azavea.Open.DAO.ClassMapColDefinition})">
            <summary>
            Generates a simplistic classmapping (without changing any column/field names) from a
            table's schema.  Intended for times when you are transferring data without really using it,
            for example from a DB to a CSV.  Will most likely only be useful for a DictionaryDAO since
            there is no defined .NET class to map to.
            
            All column names will be returned in caps.
            </summary>
            <param name="connDesc">Connection descriptor for the database.</param>
            <param name="tableName">Name of the table to generate a mapping for.</param>
            <param name="columnSorter">Since auto-generated column mappings are likely used for
                                       purposes such as exporting to a CSV, if you wish the columns
                                       to be sorted in some sort of order, you may provide an
                                       IComparer to do so.  May be null.</param>
            <returns>A class mapping, the type name will be the table name, every column will be
                     mapped to a "field" of the same name, and no types will be specified.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.XSafeScalarQuery(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,Azavea.Open.DAO.SQL.SqlTransaction,System.String,System.Collections.IEnumerable)">
            <summary>
            Similar to the "XSafeQuery" method, except this executes a
            query that returns a single result.
            </summary>
            <param name="connDesc">The database connection descriptor.  This is used both as
                                   a key for caching connections/commands as well as for
                                   getting the actual database connection the first time.</param>
            <param name="transaction">The transaction to do this as part of.</param>
            <param name="sql">The SQL query to execute.</param>
            <param name="sqlParams">A list of objects to use as parameters
            						to the SQL statement.  The list may be
            						null if there are no parameters.</param>
            <returns>The single result returned by the query.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.ReadStringsFromQuery(System.Collections.Hashtable,System.Data.IDataReader)">
            <summary>
            Just reads the results, ToString's 'em, and puts them into the parameters
            hashtable as a list called 'results'.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.ReadIntsFromQuery(System.Collections.Hashtable,System.Data.IDataReader)">
            <summary>
            Just reads the results, Convert.ToInt32's 'em, and puts them into the parameters
            hashtable as a list called 'results'.  Nulls are ignored!
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlConnectionUtilities.SetSQLOnCommand(Azavea.Open.DAO.SQL.AbstractSqlConnectionDescriptor,System.Data.IDbCommand,System.String,System.Collections.IEnumerable)">
            <summary>
            Helper to set up a command with sql and parameters and other misc stuff.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Util.DbCaches">
            <summary>
            We need to cache so many things in so many places, it made more sense to just put them
            all in one nice central location.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.Hashtables">
            <summary>
            Cache of Hashtables.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.ArrayLists">
            <summary>
            Cache of ArrayLists.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.IntLists">
            <summary>
            Cache of List&lt;int&gt;s.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.StringLists">
            <summary>
            Cache of List&lt;string&gt;s.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.EnumerableLists">
            <summary>
            Cache of List&lt;IEnumerable&gt;s.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.ObjectLists">
            <summary>
            Cache of List&lt;object&gt;s.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.StringObjectDicts">
            <summary>
            Cache of Dictionary&lt;string, object&gt;s.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.StringIntDicts">
            <summary>
            Cache of Dictionary&lt;string, int&gt;s.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.StringBuilders">
            <summary>
            Cache of StringBuilders.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.Connections">
            <summary>
            Cache of connections to all the databases we've connected to.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.Commands">
            <summary>
            Cache of all the commands we've run.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.ParamNames">
            <summary>
            Cache of "param" + nums.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.Criteria">
            <summary>
            A cache of DaoCriterias so we aren't constructing zillions of 'em.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.DbCaches.Clauses">
            <summary>
            Cache of SQL clauses so we can reuse them.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.SQL.SqlUtilities">
            <summary>
            This class holds static utility methods having to do with constructing SQL statements
            (typically statements that would then be used with the SqlConnectionUtilities class).
             
            This class is stateless and thus is threadsafe.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlUtilities.SqlParamsToString(System.String,System.Collections.IEnumerable)">
            <summary>
            Converts the sql statement and parameters into a nicely formatted
            string for output in error messages or log statements.
            </summary>
            <param name="sql">The SQL statement that needs the list of params.</param>
            <param name="sqlParams">The list of params to format.</param>
            <returns>A string containing the sql and the list of parameters, nicely formatted.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlUtilities.MakeInsertStatement(System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IList{System.Object})">
            <summary>
            Generates an insert statement to insert the values from the dictionary into
            the specified table.  Uses parameters for the values, the values will be taken
            from the dictionary and inserted into sqlParams in the same order the column names
            are inserted in the sql string.
            </summary>
            <param name="table">Name of the table to be inserted into.</param>
            <param name="columns">Dictionary of object column values keyed by string column names.</param>
            <param name="sqlParams">List to insert sql param values (in order) into.</param>
            <returns>A parameterized sql statement.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlUtilities.MakeDeleteStatement(System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IList{System.Object})">
            <summary>
            Generates a delete statement to delete rows where "key" = whereCols["key"] for everything
            in whereCols.
            </summary>
            <param name="table">Name of the table to be inserted into.</param>
            <param name="whereCols">Dictionary of object column values keyed by string column names.
            						  These columns are used in the "where" clause of the statement.  If
            						  this collection is null or empty, all rows will be updated.</param>
            <param name="sqlParams">List to insert sql param values (in order) into.</param>
            <returns>A parameterized sql statement.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlUtilities.MakeUpdateStatement(System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IList{System.Object})">
            <summary>
            Generates an update statement to update rows where "key" = whereCols["key"] for everything
            in whereCols.
            </summary>
            <param name="table">Name of the table to be inserted into.</param>
            <param name="whereCols">Dictionary of object column values keyed by string column names.
            						  These columns are used in the "where" clause of the statement.  If
            						  this collection is null or empty, all rows will be updated.</param>
            <param name="columns">Dictionary of object column values keyed by string column names.  These
            					  columns are the values that will be set on the row(s).  This collection
            					  may not be null or empty.</param>
            <param name="sqlParams">List to insert sql param values (in order) into.</param>
            <returns>A parameterized sql statement.</returns>
        </member>
        <member name="M:Azavea.Open.DAO.SQL.SqlUtilities.MakeWhereClause(System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IList{System.Object})">
            <summary>
            Helper method to generate a where clause, where keys = values.  You can simply
            concatenate this on the end of an SQL statement ("SELECT something " + MakeWhereClause(...)).
            </summary>
            <param name="whereCols">Dictionary of object column values keyed by string column names.</param>
            <param name="sqlParams">List to insert sql param values (in order) into.</param>
            <returns>Either be a zero-length string (if whereCols is empty) or
            		 a properly formatted " WHERE blah1 = ? AND blah2 = ? AND etc".</returns>
        </member>
        <member name="T:Azavea.Open.DAO.Util.ParamNameCache">
            <summary>
            Concatenating ("param" + x) wound up taking a lot of time, so here's
            a cache to hold them so we only ever have to concatenate them once.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Util.ParamNameCache.Get(System.Int32)">
            <summary>
            Returns "param" + paramNum, except without calulating it every time.
            </summary>
        </member>
        <member name="T:Azavea.Open.DAO.Util.PseudoJoiner">
            <summary>
            This class figures out how to perform a "join" across two DAOs when a native join
            is not possible (either there is no support at the data source level, or the DAOs
            are accessing different data sources, etc).
            
            Inner and Left join performance is adequate, consisting of 1 query to the left DAO
            and n queries to the right, where n is the number of rows returned by the left query.
            
            Right join performance is marginally slower than left just because we invert all
            the parameters, do a left join, and then invert the results (yes it produces correct
            output, but the inverting will slow it down slightly).
            
            Outer join performance can be bad, consisting of 1 query to the left DAO, 1 query
            to the right DAO, and then a massive in-memory comparison of all the results
            from the two queries to determine which ones match up.  The number of comparisons
            is O(n*m) where n is the number of rows from the left DAO and m is the number from
            the right DAO.
            </summary>
        </member>
        <member name="F:Azavea.Open.DAO.Util.PseudoJoiner._log">
            <summary>
            log4net logger for logging any appropriate messages.
            </summary>
        </member>
        <member name="M:Azavea.Open.DAO.Util.PseudoJoiner.Join``2(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0},Azavea.Open.DAO.IFastDaoReader{``1})">
            <summary>
            This does a "fake" join, where we query the two DAOs separately and do the
            figuring out of the join ourselves in code.
            </summary>
            <typeparam name="L">The type of object returned by the left DAO.</typeparam>
            <typeparam name="R">The type of object returned by the right DAO.</typeparam>
            <param name="crit">An object describing how to join the two DAOs.</param>
            <param name="leftDao">The "left" DAO we are joining.</param>
            <param name="rightDao">The "right" DAO we are joining.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Util.PseudoJoiner.InnerOrLeftJoin``2(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0},Azavea.Open.DAO.IFastDaoReader{``1})">
            <summary>
            Inner and left joins are pretty similar, except that we return left,null if it was
            left and we leave those records out if it was inner.
            </summary>
            <typeparam name="L">The type of object returned by the left DAO.</typeparam>
            <typeparam name="R">The type of object returned by the right DAO.</typeparam>
            <param name="crit">An object describing how to join the two DAOs.</param>
            <param name="leftDao">The "left" DAO we are joining.</param>
            <param name="rightDao">The "right" DAO we are joining.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Util.PseudoJoiner.OuterJoin``2(Azavea.Open.DAO.Criteria.Joins.DaoJoinCriteria,Azavea.Open.DAO.IFastDaoReader{``0},Azavea.Open.DAO.IFastDaoReader{``1})">
            <summary>
            Perform an outer join, meaning query both DAOs independently and figure out
            which records match up, including all records that don't match as well.
            </summary>
            <typeparam name="L">The type of object returned by the left DAO.</typeparam>
            <typeparam name="R">The type of object returned by the right DAO.</typeparam>
            <param name="crit">An object describing how to join the two DAOs.</param>
            <param name="leftDao">The "left" DAO we are joining.</param>
            <param name="rightDao">The "right" DAO we are joining.</param>
        </member>
        <member name="T:Azavea.Open.DAO.Util.PseudoJoinSorter`2">
            <summary>
            Sorts the results of a join according to the orders specified on the criteria.
            </summary>
            <typeparam name="L">The type of object returned by the left DAO.</typeparam>
            <typeparam name="R">The type of object returned by the right DAO.</typeparam>
        </member>
        <member name="M:Azavea.Open.DAO.Util.PseudoJoinSorter`2.#ctor(System.Collections.Generic.List{Azavea.Open.DAO.Criteria.Joins.JoinSortOrder},Azavea.Open.DAO.IFastDaoReader{`0},Azavea.Open.DAO.IFastDaoReader{`1})">
            <summary>
            Constructs the sorter with the things to sort on.
            </summary>
            <param name="orders">Orders from the join criteria.</param>
            <param name="leftDao">The "left" DAO we are joining.</param>
            <param name="rightDao">The "right" DAO we are joining.</param>
        </member>
        <member name="M:Azavea.Open.DAO.Util.PseudoJoinSorter`2.Compare(Azavea.Open.DAO.JoinResult{`0,`1},Azavea.Open.DAO.JoinResult{`0,`1})">
            <summary>
                                Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <returns>
                                Value 
                                Condition 
                                Less than zero
                            <paramref name="x" /> is less than <paramref name="y" />.
                                Zero
                            <paramref name="x" /> equals <paramref name="y" />.
                                Greater than zero
                            <paramref name="x" /> is greater than <paramref name="y" />.
            </returns>
            <param name="x">
                                The first object to compare.
                            </param>
            <param name="y">
                                The second object to compare.
                            </param>
        </member>
    </members>
</doc>
